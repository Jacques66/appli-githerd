#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GitHerd ‚Äî Real-time Git branch synchronizer (CustomTkinter version)

Keeps multiple Git branches aligned in real-time.
Ideal for parallel AI coding sessions (Claude Code, Cursor, etc.)
or any workflow with multiple active branches.

Copyright (c) 2026 InZeMobile
Licensed under the MIT License. See LICENSE file for details.

https://github.com/Jacques66/GitHerd
"""

import subprocess
import threading
import time
import customtkinter as ctk
from tkinter import filedialog, messagebox
from pathlib import Path
from datetime import datetime
import json
import sys
import os

# ============================================================
# CONFIG & PERSISTENCE
# ============================================================

CONFIG_DIR = Path.home() / ".config" / "githerd"
REPOS_FILE = CONFIG_DIR / "repos.json"
SETTINGS_FILE = CONFIG_DIR / "settings.json"

DEFAULT_GLOBAL_SETTINGS = {
    "git_binary": "git",
    "font_zoom": 1.0,
    "auto_start_polling": False,
    "compact_mode": False,
    "desktop_notifications": True,
    "appearance_mode": "dark",
    "color_theme": "blue",
    "last_active_tab": ""
}

APPEARANCE_MODES = ["dark", "light", "system"]
COLOR_THEMES = ["blue", "dark-blue", "green"]

DEFAULT_REPO_CONFIG = {
    "remote": "origin",
    "main_branch": "main",
    "branch_prefix": "claude/",
    "interval_seconds": 60
}

try:
    import tomllib
except ModuleNotFoundError:
    import tomli as tomllib


def load_global_settings():
    """Charge les settings globaux."""
    if SETTINGS_FILE.exists():
        try:
            with open(SETTINGS_FILE, "r") as f:
                data = json.load(f)
                settings = DEFAULT_GLOBAL_SETTINGS.copy()
                settings.update(data)
                return settings
        except Exception:
            pass
    return DEFAULT_GLOBAL_SETTINGS.copy()


def save_global_settings(settings):
    """Sauvegarde les settings globaux."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    with open(SETTINGS_FILE, "w") as f:
        json.dump(settings, f, indent=2)


def apply_theme_settings():
    """Applique les param√®tres de th√®me sauvegard√©s au d√©marrage."""
    settings = load_global_settings()
    ctk.set_appearance_mode(settings.get("appearance_mode", "dark"))
    ctk.set_default_color_theme(settings.get("color_theme", "blue"))
    # Apply font/widget scaling
    font_zoom = settings.get("font_zoom", 1.0)
    ctk.set_widget_scaling(font_zoom)
    ctk.set_window_scaling(font_zoom)


def load_repo_config(repo_path):
    """Charge la config depuis githerd.toml du repo, ou utilise les valeurs par d√©faut."""
    config_file = Path(repo_path) / "githerd.toml"
    if config_file.exists():
        try:
            cfg = tomllib.load(open(config_file, "rb"))
            return {
                "remote": cfg.get("git", {}).get("remote", DEFAULT_REPO_CONFIG["remote"]),
                "main_branch": cfg.get("git", {}).get("main_branch", DEFAULT_REPO_CONFIG["main_branch"]),
                "branch_prefix": cfg.get("git", {}).get("branch_prefix", DEFAULT_REPO_CONFIG["branch_prefix"]),
                "interval_seconds": cfg.get("sync", {}).get("interval_seconds", DEFAULT_REPO_CONFIG["interval_seconds"])
            }
        except Exception:
            pass
    return DEFAULT_REPO_CONFIG.copy()


def save_repo_config(repo_path, config):
    """Sauvegarde la config dans githerd.toml du repo."""
    config_file = Path(repo_path) / "githerd.toml"
    toml_content = f'''[git]
remote = "{config['remote']}"
main_branch = "{config['main_branch']}"
branch_prefix = "{config['branch_prefix']}"

[sync]
interval_seconds = {config['interval_seconds']}
'''
    with open(config_file, "w") as f:
        f.write(toml_content)


def load_saved_repos():
    """Charge la liste des repos sauvegard√©s."""
    if REPOS_FILE.exists():
        try:
            with open(REPOS_FILE, "r") as f:
                data = json.load(f)
                return data.get("repos", [])
        except Exception:
            pass
    return []


def save_repos(repos):
    """Sauvegarde la liste des repos."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    with open(REPOS_FILE, "w") as f:
        json.dump({"repos": repos}, f, indent=2)


def detect_repo_settings(repo_path, git_binary="git"):
    """D√©tecte automatiquement remote et main_branch du repo."""
    settings = DEFAULT_REPO_CONFIG.copy()

    code, out, _ = run_git([git_binary, "remote"], cwd=repo_path)
    if code == 0 and out:
        remotes = out.splitlines()
        if remotes:
            settings["remote"] = remotes[0]

    remote = settings["remote"]
    code, out, _ = run_git(
        [git_binary, "symbolic-ref", f"refs/remotes/{remote}/HEAD"],
        cwd=repo_path
    )
    if code == 0 and out:
        parts = out.split("/")
        if len(parts) >= 4:
            settings["main_branch"] = parts[-1]
    else:
        code, out, _ = run_git(
            [git_binary, "branch", "-r", "--list", f"{remote}/main"],
            cwd=repo_path
        )
        if code == 0 and out.strip():
            settings["main_branch"] = "main"
        else:
            code, out, _ = run_git(
                [git_binary, "branch", "-r", "--list", f"{remote}/master"],
                cwd=repo_path
            )
            if code == 0 and out.strip():
                settings["main_branch"] = "master"

    return settings


HELP_TEXT = """GitHerd ‚Äî Real-time Git branch synchronizer

Keeps multiple Git branches aligned in real-time.
Ideal for parallel AI coding sessions or any workflow
with multiple active branches.

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

HANDLED CASES:

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Situation                               ‚îÇ Action              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Nothing to do                           ‚îÇ Idle                ‚îÇ
‚îÇ Local main ahead                        ‚îÇ Auto push           ‚îÇ
‚îÇ Branches behind main                    ‚îÇ Auto push to sync   ‚îÇ
‚îÇ 1 branch ahead (not diverged)           ‚îÇ Fast-forward + push ‚îÇ
‚îÇ 1+ diverged branch, disjoint files      ‚îÇ Merge button        ‚îÇ
‚îÇ 1+ diverged branch, common files        ‚îÇ STOP                ‚îÇ
‚îÇ 2+ branches ahead, disjoint files       ‚îÇ Merge button        ‚îÇ
‚îÇ 2+ branches ahead, common files         ‚îÇ STOP                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

MULTI-REPO:

- File menu > Add repository (Ctrl+O)
- Each tab manages a repository independently
- Repositories are saved between sessions

TAB INDICATORS:
- Green background = Polling active
- Gray background = Polling inactive
- Red background = STOP (action required or error)

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

KEYBOARD SHORTCUTS:

- Ctrl+O : Add repository
- Ctrl+S : Stop all polling
- Ctrl+R : Restart
- Ctrl+Q : Quit

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

https://github.com/Jacques66/GitHerd
"""

# ============================================================
# GIT HELPERS
# ============================================================

def run_git(cmd, cwd=None):
    try:
        p = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            cwd=cwd,
            timeout=30
        )
        return p.returncode, p.stdout.strip(), p.stderr.strip()
    except subprocess.TimeoutExpired:
        return 1, "", "Timeout"
    except FileNotFoundError:
        return 1, "", f"Command not found: {cmd[0]}"
    except Exception as e:
        return 1, "", str(e)


def commits_ahead(base, tip, cwd=None, git="git"):
    code, out, err = run_git([git, "rev-list", "--count", f"{base}..{tip}"], cwd=cwd)
    if code != 0:
        raise RuntimeError(err)
    return int(out)


def commits_behind(base, tip, cwd=None, git="git"):
    code, out, err = run_git([git, "rev-list", "--count", f"{tip}..{base}"], cwd=cwd)
    if code != 0:
        return 0
    return int(out)


def get_tracked_branches(remote, prefix, cwd=None, git="git"):
    code, out, err = run_git(
        [git, "for-each-ref", "--format=%(refname:short)",
         f"refs/remotes/{remote}/{prefix}"],
        cwd=cwd
    )
    if code != 0:
        raise RuntimeError(err)
    return out.splitlines() if out else []


def get_changed_files(base, tip, cwd=None, git="git"):
    code, out, err = run_git([git, "diff", "--name-only", f"{base}...{tip}"], cwd=cwd)
    if code != 0:
        return set()
    return set(out.splitlines()) if out else set()


def are_files_disjoint(branches, main_ref, remote, cwd=None, git="git"):
    all_files = []
    for branch in branches:
        files = get_changed_files(main_ref, f"{remote}/{branch}", cwd=cwd, git=git)
        all_files.append(files)

    for i in range(len(all_files)):
        for j in range(i + 1, len(all_files)):
            if all_files[i] & all_files[j]:
                return False
    return True


def local_main_ahead(remote, main, cwd=None, git="git"):
    try:
        return commits_ahead(f"{remote}/{main}", main, cwd=cwd, git=git)
    except:
        return 0


def delete_remote_branch(branch_name, remote, cwd=None, git="git"):
    code, out, err = run_git([git, "push", remote, "--delete", branch_name], cwd=cwd)
    return code == 0, err


def is_git_repo(path, git="git"):
    code, _, _ = run_git([git, "rev-parse", "--git-dir"], cwd=path)
    return code == 0


def check_git_health(repo_path, remote, main_branch, git="git"):
    code, _, err = run_git([git, "rev-parse", "--git-dir"], cwd=repo_path)
    if code != 0:
        return False, f"Not a Git repository: {err}"

    code, out, err = run_git([git, "remote"], cwd=repo_path)
    if code != 0:
        return False, f"Git remote error: {err}"
    if remote not in out.splitlines():
        return False, f"Remote '{remote}' not found"

    code, _, err = run_git([git, "fetch", remote, "--dry-run"], cwd=repo_path)
    if code != 0:
        return False, f"Fetch failed: {err}"

    return True, ""


# ============================================================
# SOUND & NOTIFICATIONS
# ============================================================

SOUNDS = {
    "commit": "/usr/share/sounds/freedesktop/stereo/message-new-instant.oga",
    "success": "/usr/share/sounds/freedesktop/stereo/complete.oga",
    "error": "/usr/share/sounds/freedesktop/stereo/dialog-error.oga",
    "bell": "/usr/share/sounds/freedesktop/stereo/bell.oga"
}


def play_sound(sound_type="bell"):
    sound_file = SOUNDS.get(sound_type, SOUNDS["bell"])
    try:
        subprocess.run(
            ["paplay", sound_file],
            stderr=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL
        )
    except FileNotFoundError:
        print("\a", end="", flush=True)


def send_notification(title, message, urgency="normal"):
    try:
        subprocess.run(
            ["notify-send", "-u", urgency, "-a", "GitHerd", title, message],
            stderr=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL
        )
    except FileNotFoundError:
        pass


def play_beep():
    play_sound("bell")


# ============================================================
# REPO TAB CONTENT
# ============================================================

class RepoTabContent(ctk.CTkFrame):
    """Contenu d'un onglet g√©rant un seul d√©p√¥t Git."""

    def __init__(self, parent, repo_path, app, tab_name):
        super().__init__(parent)

        self.repo_path = Path(repo_path)
        self.app = app
        self.tab_name = tab_name
        self.git = app.global_settings.get("git_binary", "git")

        # Charger config repo
        self.repo_config = load_repo_config(repo_path)
        self.remote = self.repo_config["remote"]
        self.main = self.repo_config["main_branch"]
        self.prefix = self.repo_config["branch_prefix"]
        self.interval = self.repo_config["interval_seconds"]

        self.lock = threading.Lock()
        self.polling = False
        self.log_visible = True
        self.last_commit_count = {}
        self.pending_branches = []
        self.git_healthy = True
        self.git_error = ""
        self.next_poll_time = 0
        self.countdown_job = None
        self.has_update = False
        self.base_tab_name = Path(repo_path).name

        # TOP BAR (status)
        top_bar = ctk.CTkFrame(self)
        top_bar.pack(fill="x", padx=10, pady=6)

        self.state_label = ctk.CTkLabel(
            top_bar,
            text="Starting‚Ä¶",
            font=ctk.CTkFont(size=16, weight="bold")
        )
        self.state_label.pack(anchor="w", padx=5)

        # Info + countdown
        info_frame = ctk.CTkFrame(top_bar, fg_color="transparent")
        info_frame.pack(anchor="w", fill="x")

        self.info_label = ctk.CTkLabel(
            info_frame,
            text="Analyzing‚Ä¶",
            font=ctk.CTkFont(size=13),
            wraplength=600
        )
        self.info_label.pack(side="left", padx=5)

        self.countdown_label = ctk.CTkLabel(
            info_frame,
            text="",
            font=ctk.CTkFont(size=13),
            text_color="gray"
        )
        self.countdown_label.pack(side="left", padx=10)

        # BUTTONS
        self.buttons_frame = ctk.CTkFrame(self, fg_color="transparent")
        self.buttons_frame.pack(fill="x", padx=10, pady=8)

        self.btn_poll = ctk.CTkButton(
            self.buttons_frame,
            text="‚ñ∂ Start polling",
            command=self.toggle_polling,
            width=140
        )
        self.btn_poll.pack(side="left", padx=6)

        self.btn_sync = ctk.CTkButton(
            self.buttons_frame,
            text="‚ö° Sync now",
            command=self.manual_sync,
            width=120
        )
        self.btn_sync.pack(side="left", padx=6)

        self.btn_merge = ctk.CTkButton(
            self.buttons_frame,
            text="üîÄ Merge",
            command=self.manual_merge,
            width=100,
            fg_color="#DAA520",
            hover_color="#B8860B"
        )
        # Cach√© par d√©faut

        self.btn_config = ctk.CTkButton(
            self.buttons_frame,
            text="‚öô Options",
            command=self.show_config_dialog,
            width=100
        )
        self.btn_config.pack(side="right", padx=6)

        self.btn_close = ctk.CTkButton(
            self.buttons_frame,
            text="‚úï Close",
            command=lambda: self.app.close_tab(self.tab_name),
            width=100,
            fg_color="#8B0000",
            hover_color="#CD5C5C"
        )
        self.btn_close.pack(side="right", padx=6)

        # LOG SECTION
        self.log_header = ctk.CTkFrame(self, fg_color="transparent")
        self.log_header.pack(fill="x", padx=10, pady=(10, 0))

        self.btn_toggle_log = ctk.CTkButton(
            self.log_header,
            text="‚ñº",
            width=30,
            command=self.toggle_log
        )
        self.btn_toggle_log.pack(side="left")

        ctk.CTkLabel(
            self.log_header,
            text="Log",
            font=ctk.CTkFont(size=13, weight="bold")
        ).pack(side="left", padx=4)

        # LOG TEXTBOX
        self.log_frame = ctk.CTkFrame(self, fg_color="transparent")
        self.log_frame.pack(fill="both", expand=True, padx=10, pady=6)

        self.log = ctk.CTkTextbox(
            self.log_frame,
            font=ctk.CTkFont(family="Consolas", size=12),
            height=250,
            state="disabled"
        )
        self.log.pack(fill="both", expand=True)

        # D√âMARRAGE
        threading.Thread(target=self.initial_scan, daemon=True).start()

    # --------------------------------------------------------
    # GIT HEALTH & TAB STATE
    # --------------------------------------------------------

    def check_and_update_health(self):
        ok, err = check_git_health(self.repo_path, self.remote, self.main, self.git)
        self.git_healthy = ok
        self.git_error = err

        if not ok:
            self.disable_tab(err)
        else:
            self.enable_tab()

        return ok

    def disable_tab(self, error_msg):
        self.state_label.configure(text="ERROR ‚Äî Git not working")
        self.info_label.configure(text=error_msg)
        self.btn_poll.configure(state="disabled")
        self.btn_sync.configure(state="disabled")
        self.polling = False
        self.btn_poll.configure(text="‚ñ∂ Start polling")
        self.after(0, lambda: self.app.update_tab_color(self))

    def enable_tab(self):
        self.btn_poll.configure(state="normal")
        self.btn_sync.configure(state="normal")

    # --------------------------------------------------------
    # CONFIG DIALOG
    # --------------------------------------------------------

    def show_config_dialog(self):
        dialog = ctk.CTkToplevel(self.app)
        dialog.title(f"Options ‚Äî {self.repo_path.name}")
        dialog.geometry("450x300")
        dialog.transient(self.app)
        dialog.resizable(False, False)

        # Wait for window to be created
        dialog.update()

        # Main frame with internal padding
        main_frame = ctk.CTkFrame(dialog)
        main_frame.pack(fill="both", expand=True, padx=15, pady=15)

        # Section title
        ctk.CTkLabel(main_frame, text="Repository settings",
                    font=ctk.CTkFont(weight="bold")).grid(
            row=0, column=0, columnspan=2, sticky="w", padx=15, pady=(15, 10))

        # Remote
        ctk.CTkLabel(main_frame, text="Remote:").grid(
            row=1, column=0, sticky="w", padx=15, pady=8)
        remote_entry = ctk.CTkEntry(main_frame, width=250)
        remote_entry.insert(0, self.remote)
        remote_entry.grid(row=1, column=1, sticky="ew", padx=(10, 15), pady=8)

        # Main branch
        ctk.CTkLabel(main_frame, text="Main branch:").grid(
            row=2, column=0, sticky="w", padx=15, pady=8)
        main_entry = ctk.CTkEntry(main_frame, width=250)
        main_entry.insert(0, self.main)
        main_entry.grid(row=2, column=1, sticky="ew", padx=(10, 15), pady=8)

        # Branch prefix
        ctk.CTkLabel(main_frame, text="Branch prefix:").grid(
            row=3, column=0, sticky="w", padx=15, pady=8)
        prefix_entry = ctk.CTkEntry(main_frame, width=250)
        prefix_entry.insert(0, self.prefix)
        prefix_entry.grid(row=3, column=1, sticky="ew", padx=(10, 15), pady=8)

        # Interval
        ctk.CTkLabel(main_frame, text="Interval (sec):").grid(
            row=4, column=0, sticky="w", padx=15, pady=8)
        interval_entry = ctk.CTkEntry(main_frame, width=100)
        interval_entry.insert(0, str(self.interval))
        interval_entry.grid(row=4, column=1, sticky="w", padx=(10, 15), pady=8)

        main_frame.columnconfigure(1, weight=1)

        # Buttons
        btn_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        btn_frame.pack(fill="x", padx=15, pady=15)

        def save_config():
            self.remote = remote_entry.get().strip()
            self.main = main_entry.get().strip()
            self.prefix = prefix_entry.get().strip()
            try:
                self.interval = int(interval_entry.get().strip())
            except ValueError:
                self.interval = 60

            self.repo_config = {
                "remote": self.remote,
                "main_branch": self.main,
                "branch_prefix": self.prefix,
                "interval_seconds": self.interval
            }

            try:
                save_repo_config(self.repo_path, self.repo_config)
                self.log_msg("Configuration saved")
                self.check_and_update_health()
            except Exception as e:
                messagebox.showerror("Error", f"Unable to save: {e}", parent=dialog)
                return

            dialog.destroy()

        ctk.CTkButton(btn_frame, text="Save", command=save_config).pack(side="left", padx=5)
        ctk.CTkButton(btn_frame, text="Cancel", command=dialog.destroy).pack(side="left", padx=5)

        # Grab focus after widgets are created
        dialog.grab_set()

    def open_folder(self):
        try:
            subprocess.run(["xdg-open", str(self.repo_path)],
                          stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)
        except:
            pass

    def delete_branch(self, branch_name):
        if not messagebox.askyesno(
            "Confirm deletion",
            f"Delete remote branch '{branch_name}'?\n\nThis action is irreversible.",
            parent=self
        ):
            return

        self.log_msg(f"Deleting {branch_name}‚Ä¶")
        success, err = delete_remote_branch(branch_name, self.remote,
                                           cwd=self.repo_path, git=self.git)

        if success:
            self.log_msg(f"Branch {branch_name} deleted")
            self.manual_sync()
        else:
            self.log_msg(f"Error: {err}")

    # --------------------------------------------------------
    # TOGGLE LOG
    # --------------------------------------------------------

    def toggle_log(self):
        if self.log_visible:
            self.log_frame.pack_forget()
            self.btn_toggle_log.configure(text="‚ñ∂")
        else:
            self.log_frame.pack(fill="both", expand=True, padx=10, pady=6)
            self.btn_toggle_log.configure(text="‚ñº")
        self.log_visible = not self.log_visible

    # --------------------------------------------------------
    # MERGE BUTTON VISIBILITY
    # --------------------------------------------------------

    def show_merge_button(self):
        self.btn_merge.pack(side="left", padx=6)

    def hide_merge_button(self):
        self.btn_merge.pack_forget()

    # --------------------------------------------------------
    # POLLING CONTROL
    # --------------------------------------------------------

    def stop_polling(self):
        self.polling = False
        self.btn_poll.configure(text="‚ñ∂ Start polling")
        self.stop_countdown()
        self.after(0, lambda: self.app.update_tab_color(self))

    def _mark_if_not_active(self):
        try:
            if self.app.current_tab != self.tab_name:
                self.app.mark_tab_updated(self)
        except Exception:
            pass

    # --------------------------------------------------------
    # LOGGING
    # --------------------------------------------------------

    def log_msg(self, txt):
        ts = datetime.now().strftime("%H:%M:%S")
        self.log.configure(state="normal")
        self.log.insert("end", f"[{ts}] {txt}\n")
        self.log.see("end")
        self.log.configure(state="disabled")

    def export_log(self):
        filename = filedialog.asksaveasfilename(
            title="Export log",
            defaultextension=".txt",
            initialfile=f"githerd-{self.repo_path.name}-{datetime.now().strftime('%Y%m%d-%H%M%S')}.txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        if filename:
            try:
                content = self.log.get("1.0", "end")
                with open(filename, "w") as f:
                    f.write(f"GitHerd Log - {self.repo_path}\n")
                    f.write(f"Exported: {datetime.now()}\n")
                    f.write("=" * 50 + "\n\n")
                    f.write(content)
                self.log_msg(f"Log exported to {filename}")
            except Exception as e:
                messagebox.showerror("Error", f"Unable to export: {e}", parent=self)

    # --------------------------------------------------------
    # COUNTDOWN
    # --------------------------------------------------------

    def start_countdown(self):
        self.update_countdown()

    def stop_countdown(self):
        if self.countdown_job:
            self.after_cancel(self.countdown_job)
            self.countdown_job = None
        self.countdown_label.configure(text="")

    def update_countdown(self):
        if not self.polling:
            self.countdown_label.configure(text="")
            return

        remaining = int(self.next_poll_time - time.time())
        if remaining > 0:
            self.countdown_label.configure(text=f"(next sync: {remaining}s)")
        else:
            self.countdown_label.configure(text="(sync...)")

        self.countdown_job = self.after(1000, self.update_countdown)

    # --------------------------------------------------------
    # PUSH ALL BRANCHES
    # --------------------------------------------------------

    def push_main_and_branches(self):
        self.log_msg(f"git push {self.remote} {self.main}")
        code, out, err = run_git([self.git, "push", self.remote, self.main],
                                cwd=self.repo_path)
        if code != 0:
            self.log_msg(f"ERROR push main: {err}")
            self.state_label.configure(text="ERROR")
            self.stop_polling()
            return False
        self.log_msg(out if out else "  (ok)")

        branches = get_tracked_branches(self.remote, self.prefix,
                                        cwd=self.repo_path, git=self.git)
        for b in branches:
            target = b.replace(f"{self.remote}/", "")
            refspec = f"{self.main}:{target}"
            self.log_msg(f"git push {self.remote} {refspec}")
            code, out, err = run_git([self.git, "push", self.remote, refspec],
                                    cwd=self.repo_path)
            if code != 0:
                self.log_msg(f"ERROR push {target}: {err}")
                self.state_label.configure(text="STOP ‚Äî Push failed")
                self.info_label.configure(text=f"Push to {target} failed")
                self.stop_polling()
                return False
            self.log_msg(out if out else "  (ok)")

        return True

    # --------------------------------------------------------
    # CORE LOGIC
    # --------------------------------------------------------

    def sync(self):
        if not self.lock.acquire(blocking=False):
            return
        try:
            self._do_sync()
        finally:
            self.lock.release()

    def _do_sync(self):
        self.state_label.configure(text="Sync‚Ä¶")
        self.hide_merge_button()
        self.pending_branches = []

        self.log_msg(f"git fetch {self.remote}")
        code, _, err = run_git([self.git, "fetch", self.remote], cwd=self.repo_path)
        if code != 0:
            self.log_msg(f"ERROR fetch: {err}")
            self.state_label.configure(text="ERROR")
            self.stop_polling()
            return

        local_ahead = local_main_ahead(self.remote, self.main,
                                       cwd=self.repo_path, git=self.git)
        if local_ahead > 0:
            self.log_msg(f"Local main ahead by {local_ahead} commits ‚Üí push")
            if self.push_main_and_branches():
                self.state_label.configure(text="Sync OK")
                self.info_label.configure(text=f"Pushed {local_ahead} local commits")
                self.log_msg("Push completed successfully")
            return

        branches = get_tracked_branches(self.remote, self.prefix,
                                        cwd=self.repo_path, git=self.git)
        self.log_msg(f"Branches {self.prefix}*: {len(branches)}")

        ahead_branches = []
        diverged_branches = []
        new_commits_detected = False

        for b in branches:
            ahead = commits_ahead(f"{self.remote}/{self.main}", b,
                                 cwd=self.repo_path, git=self.git)
            behind = commits_behind(f"{self.remote}/{self.main}", b,
                                   cwd=self.repo_path, git=self.git)

            if ahead > 0:
                short_name = b.replace(f"{self.remote}/", "")

                if behind > 0:
                    diverged_branches.append((short_name, ahead, behind))
                    self.log_msg(f"  {short_name}: +{ahead}/-{behind} (DIVERGED)")
                else:
                    ahead_branches.append((short_name, ahead))
                    self.log_msg(f"  {short_name}: +{ahead} commits")

                prev = self.last_commit_count.get(short_name, 0)
                if ahead > prev:
                    new_commits_detected = True
                self.last_commit_count[short_name] = ahead

        if new_commits_detected:
            self.log_msg("New commit detected!")
            threading.Thread(target=lambda: play_sound("commit"), daemon=True).start()
            if self.app.global_settings.get("desktop_notifications", True):
                send_notification(
                    f"GitHerd ‚Äî {self.repo_path.name}",
                    "New commit detected!",
                    "normal"
                )
            self.after(0, self._mark_if_not_active)

        total_problematic = len(ahead_branches) + len(diverged_branches)

        if total_problematic == 0:
            behind_branches = []
            for b in branches:
                behind = commits_behind(f"{self.remote}/{self.main}", b,
                                       cwd=self.repo_path, git=self.git)
                if behind > 0:
                    short_name = b.replace(f"{self.remote}/", "")
                    behind_branches.append((short_name, behind))
                    self.log_msg(f"  {short_name}: -{behind} commits (behind)")

            if behind_branches:
                self.log_msg(f"Synchronizing {len(behind_branches)} branches behind‚Ä¶")
                for branch_name, _ in behind_branches:
                    refspec = f"{self.main}:{branch_name}"
                    self.log_msg(f"git push {self.remote} {refspec}")
                    code, out, err = run_git(
                        [self.git, "push", self.remote, refspec],
                        cwd=self.repo_path
                    )
                    if code != 0:
                        self.log_msg(f"ERROR push {branch_name}: {err}")
                        self.state_label.configure(text="ERROR")
                        self.stop_polling()
                        return
                    self.log_msg(out if out else "  (ok)")

                self.state_label.configure(text="Sync OK")
                self.info_label.configure(text=f"{len(behind_branches)} branches synchronized")
                self.log_msg("Behind branches synchronized")
                return

            self.state_label.configure(text="Idle")
            self.info_label.configure(text="All branches are synchronized")
            self.log_msg("Nothing to do")
            self.last_commit_count.clear()
            return

        if len(diverged_branches) > 0 or len(ahead_branches) > 1:
            all_names = [b[0] for b in diverged_branches] + [b[0] for b in ahead_branches]
            self.pending_branches = all_names

            self.log_msg("Checking modified files‚Ä¶")
            disjoint = are_files_disjoint(all_names, f"{self.remote}/{self.main}",
                                         self.remote, cwd=self.repo_path, git=self.git)

            if len(diverged_branches) > 0:
                diverged_names = [f"{b[0]} (+{b[1]}/-{b[2]})" for b in diverged_branches]
                msg = f"Diverged branches: {', '.join(diverged_names)}"
            else:
                msg = f"Multiple branches: {', '.join(all_names)}"

            if disjoint:
                self.state_label.configure(text="STOP ‚Äî Merge possible")
                self.info_label.configure(text=f"Disjoint files. {msg}")
                self.log_msg("Disjoint files ‚Äî manual merge possible")
                self.show_merge_button()
            else:
                self.state_label.configure(text="STOP ‚Äî Human action required")
                self.info_label.configure(text=f"Potential file conflict. {msg}")
                self.log_msg("STOP: common files detected")
            self.stop_polling()
            return

        leader, _ = ahead_branches[0]
        self.log_msg(f"git pull --ff-only {self.remote} {leader}")
        code, out, err = run_git(
            [self.git, "pull", "--ff-only", self.remote, leader],
            cwd=self.repo_path
        )
        if code != 0:
            self.log_msg(f"ERROR pull: {err}")
            self.state_label.configure(text="ERROR")
            self.info_label.configure(text=f"Pull failed: {err[:100]}")
            self.stop_polling()
            return
        self.log_msg(out if out else "  (ok)")

        if not self.push_main_and_branches():
            return

        self.last_commit_count[leader] = 0
        self.state_label.configure(text="Sync OK")
        branches = get_tracked_branches(self.remote, self.prefix,
                                        cwd=self.repo_path, git=self.git)
        other_count = len(branches) - 1
        self.info_label.configure(text=f"Pull from {leader}, push to {other_count} other branches")
        self.log_msg("Sync completed successfully")

    # --------------------------------------------------------
    # MANUAL MERGE
    # --------------------------------------------------------

    def manual_merge(self):
        threading.Thread(target=self._do_merge, daemon=True).start()

    def _do_merge(self):
        if not self.lock.acquire(blocking=False):
            return
        try:
            self._do_merge_impl()
        finally:
            self.lock.release()

    def _do_merge_impl(self):
        if not self.pending_branches:
            self.log_msg("No branches pending merge")
            return

        self.state_label.configure(text="Merging‚Ä¶")
        self.hide_merge_button()

        branches = self.pending_branches[:]
        self.log_msg(f"Merging {len(branches)} branches: {', '.join(branches)}")

        for branch in branches:
            self.log_msg(f"git merge {self.remote}/{branch}")
            code, out, err = run_git(
                [self.git, "merge", f"{self.remote}/{branch}", "-m", f"Merge {branch}"],
                cwd=self.repo_path
            )
            if code != 0:
                self.log_msg(f"ERROR merge {branch}: {err}")
                self.state_label.configure(text="ERROR ‚Äî Merge failed")
                self.info_label.configure(text=f"Merge of {branch} failed")
                run_git([self.git, "merge", "--abort"], cwd=self.repo_path)
                self.stop_polling()
                return
            self.log_msg(out if out else "  (ok)")

        if not self.push_main_and_branches():
            return

        self.pending_branches = []
        self.last_commit_count.clear()
        self.state_label.configure(text="Merge OK")
        self.info_label.configure(text=f"Merged {len(branches)} branches")
        self.log_msg("Merge completed successfully")

        self.after(0, lambda: self.app.update_tab_color(self))

    # --------------------------------------------------------
    # INITIAL SCAN
    # --------------------------------------------------------

    def initial_scan(self):
        if not self.check_and_update_health():
            self.log_msg(f"Error: {self.git_error}")
            return

        try:
            run_git([self.git, "fetch", self.remote], cwd=self.repo_path)

            local_ahead = local_main_ahead(self.remote, self.main,
                                          cwd=self.repo_path, git=self.git)
            if local_ahead > 0:
                self.state_label.configure(text="Local main ahead")
                self.info_label.configure(text=f"+{local_ahead} commits to push ‚Äî click Sync now")
                return

            branches = get_tracked_branches(self.remote, self.prefix,
                                           cwd=self.repo_path, git=self.git)

            ahead_list = []
            diverged_list = []

            for b in branches:
                ahead = commits_ahead(f"{self.remote}/{self.main}", b,
                                     cwd=self.repo_path, git=self.git)
                behind = commits_behind(f"{self.remote}/{self.main}", b,
                                       cwd=self.repo_path, git=self.git)

                if ahead > 0:
                    short_name = b.replace(f"{self.remote}/", "")
                    self.last_commit_count[short_name] = ahead

                    if behind > 0:
                        diverged_list.append((short_name, ahead, behind))
                    else:
                        ahead_list.append(short_name)

            total = len(ahead_list) + len(diverged_list)

            if total == 0:
                behind_list = []
                for b in branches:
                    behind = commits_behind(f"{self.remote}/{self.main}", b,
                                           cwd=self.repo_path, git=self.git)
                    if behind > 0:
                        short_name = b.replace(f"{self.remote}/", "")
                        behind_list.append((short_name, behind))

                if behind_list:
                    names = [f"{b[0]} (-{b[1]})" for b in behind_list]
                    self.state_label.configure(text="Branches behind")
                    self.info_label.configure(text=f"To synchronize: {', '.join(names)}")
                else:
                    self.state_label.configure(text="Idle")
                    self.info_label.configure(text="All branches are synchronized")
            elif len(diverged_list) == 0 and len(ahead_list) == 1:
                self.state_label.configure(text="1 branch ahead")
                self.info_label.configure(text=f"Ready to sync: {ahead_list[0]}")
            else:
                all_names = [b[0] for b in diverged_list] + ahead_list
                self.pending_branches = all_names

                disjoint = are_files_disjoint(all_names, f"{self.remote}/{self.main}",
                                             self.remote, cwd=self.repo_path, git=self.git)

                if len(diverged_list) > 0:
                    diverged_info = [f"{b[0]} (+{b[1]}/-{b[2]})" for b in diverged_list]
                    msg = f"Diverged: {', '.join(diverged_info)}"
                else:
                    msg = f"Multiple branches: {', '.join(all_names)}"

                if disjoint:
                    self.state_label.configure(text="STOP ‚Äî Merge possible")
                    self.info_label.configure(text=f"Disjoint files. {msg}")
                    self.after(100, self.show_merge_button)
                else:
                    self.state_label.configure(text="STOP ‚Äî Human action required")
                    self.info_label.configure(text=msg)

                self.after(0, lambda: self.app.update_tab_color(self))

        except Exception as e:
            self.state_label.configure(text="ERROR")
            self.info_label.configure(text=str(e))
            self.after(0, lambda: self.app.update_tab_color(self))

    # --------------------------------------------------------
    # POLLING
    # --------------------------------------------------------

    def polling_loop(self):
        next_tick = time.time()
        while self.polling:
            self.sync()
            try:
                cfg = load_repo_config(self.repo_path)
                interval = cfg.get("interval_seconds", self.interval)
            except:
                interval = self.interval

            next_tick += interval
            self.next_poll_time = next_tick
            sleep_time = max(0, next_tick - time.time())
            time.sleep(sleep_time)

    def toggle_polling(self):
        if not self.git_healthy:
            return
        self.polling = not self.polling
        self.btn_poll.configure(
            text="‚è∏ Stop polling" if self.polling else "‚ñ∂ Start polling"
        )
        if self.polling:
            self.next_poll_time = time.time() + self.interval
            self.start_countdown()
            threading.Thread(target=self.polling_loop, daemon=True).start()
        else:
            self.stop_countdown()
        self.app.update_tab_color(self)
        self.app.update_title()

    def manual_sync(self):
        if not self.git_healthy:
            return
        threading.Thread(target=self.sync, daemon=True).start()


# ============================================================
# MAIN APP
# ============================================================

class App(ctk.CTk):
    def __init__(self):
        super().__init__()

        self.tabs = {}  # tab_name -> RepoTabContent
        self.tab_paths = {}  # tab_name -> repo_path
        self.global_settings = load_global_settings()

        self.title("GitHerd")
        self.geometry("1000x750")

        # MENU BAR
        import tkinter as tk
        import tkinter.font as tkfont

        # Calculate menu font size based on font_zoom
        font_zoom = self.global_settings.get("font_zoom", 1.0)
        menu_font_size = int(10 * font_zoom)
        menu_font = tkfont.Font(family="sans-serif", size=menu_font_size)

        self.menubar = tk.Menu(self, font=menu_font)
        self.config(menu=self.menubar)

        # File menu
        file_menu = tk.Menu(self.menubar, tearoff=0, font=menu_font)
        self.menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="Add repository...", command=self.add_repo_dialog,
                             accelerator="Ctrl+O")
        file_menu.add_command(label="Stop all polling", command=self.stop_all_polling,
                             accelerator="Ctrl+S")
        file_menu.add_separator()
        file_menu.add_command(label="Restart", command=self.restart_app,
                             accelerator="Ctrl+R")
        file_menu.add_command(label="Quit", command=self.on_close, accelerator="Ctrl+Q")

        # Repository menu
        self.repo_menu = tk.Menu(self.menubar, tearoff=0, font=menu_font)
        self.menubar.add_cascade(label="Repository", menu=self.repo_menu)
        self.repo_menu.add_command(label="Options...", command=self.show_current_repo_options)
        self.repo_menu.add_command(label="Open folder", command=self.open_current_folder)
        self.repo_menu.add_separator()
        self.repo_menu.add_command(label="Close", command=self.close_current_tab)

        # ? menu (Options + Help)
        help_menu = tk.Menu(self.menubar, tearoff=0, font=menu_font)
        self.menubar.add_cascade(label="?", menu=help_menu)
        help_menu.add_command(label="Settings...", command=self.show_global_settings)
        help_menu.add_separator()
        help_menu.add_command(label="About GitHerd", command=self.show_help)

        # Raccourcis clavier
        self.bind("<Control-o>", lambda e: self.add_repo_dialog())
        self.bind("<Control-s>", lambda e: self.stop_all_polling())
        self.bind("<Control-r>", lambda e: self.restart_app())
        self.bind("<Control-q>", lambda e: self.on_close())

        # CUSTOM TAB BAR (left-aligned with colors)
        self.tab_bar = ctk.CTkFrame(self, height=40)
        self.tab_bar.pack(fill="x", padx=10, pady=(10, 0))

        # Container for tab content
        self.content_container = ctk.CTkFrame(self)
        self.content_container.pack(fill="both", expand=True, padx=10, pady=(5, 10))

        # Tab buttons dict: tab_name -> CTkButton
        self.tab_buttons = {}
        # Tab frames dict: tab_name -> CTkFrame (content)
        self.tab_frames = {}
        # Current active tab
        self.current_tab = None

        # Charger les repos sauvegard√©s
        self.load_saved_repos()

        # Si aucun repo, ouvrir le dialogue
        if not self.tabs:
            self.after(100, self.add_repo_dialog)

        # Sauvegarder √† la fermeture
        self.protocol("WM_DELETE_WINDOW", self.on_close)

        # ALWAYS ON TOP
        self.after(500, self.set_always_on_top)

    def set_always_on_top(self):
        self.attributes("-topmost", True)
        try:
            subprocess.run(
                ["wmctrl", "-r", self.title(), "-b", "add,above"],
                stderr=subprocess.DEVNULL,
                stdout=subprocess.DEVNULL
            )
        except FileNotFoundError:
            pass

    # --------------------------------------------------------
    # TAB COLOR MANAGEMENT
    # --------------------------------------------------------

    def get_tab_bg_state(self, tab):
        """Retourne l'√©tat de background pour l'onglet."""
        if not tab.git_healthy:
            return "red"
        if tab.pending_branches and not tab.polling:
            return "red"
        if tab.polling:
            return "green"
        return "default"

    def update_tab_color(self, tab):
        """Met √† jour la couleur de l'onglet."""
        tab_name = tab.tab_name
        if tab_name not in self.tab_buttons:
            return

        btn = self.tab_buttons[tab_name]
        bg_state = self.get_tab_bg_state(tab)

        # Define colors
        if bg_state == "green":
            fg_color = "#2d5a2d"  # Dark green
            hover_color = "#3d7a3d"
        elif bg_state == "red":
            fg_color = "#8b2020"  # Dark red
            hover_color = "#ab3030"
        else:
            fg_color = "#333333"  # Default gray
            hover_color = "#444444"

        # Update button colors
        btn.configure(fg_color=fg_color, hover_color=hover_color)

        # Update text with indicator if has_update
        text = tab.base_tab_name
        if tab.has_update:
            text = "‚óè " + text
        btn.configure(text=text)

        self.update_title()

    def mark_tab_updated(self, tab):
        """Marque l'onglet comme ayant une mise √† jour."""
        if not tab.has_update:
            tab.has_update = True
            self.update_tab_color(tab)

    def clear_tab_marker(self, tab):
        """Efface le marqueur de mise √† jour."""
        if tab.has_update:
            tab.has_update = False
            self.update_tab_color(tab)

    # --------------------------------------------------------
    # GLOBAL SETTINGS DIALOG
    # --------------------------------------------------------

    def show_global_settings(self):
        dialog = ctk.CTkToplevel(self)
        dialog.title("Settings")
        dialog.geometry("500x520")
        dialog.transient(self)
        dialog.grab_set()
        dialog.resizable(False, False)

        main_frame = ctk.CTkFrame(dialog)
        main_frame.pack(fill="both", expand=True, padx=15, pady=15)

        row = 0

        # === APPEARANCE SECTION ===
        ctk.CTkLabel(main_frame, text="Appearance", font=ctk.CTkFont(weight="bold")).grid(
            row=row, column=0, columnspan=3, sticky="w", pady=(0, 8))
        row += 1

        # Appearance mode
        ctk.CTkLabel(main_frame, text="Mode:").grid(row=row, column=0, sticky="w", pady=8)
        appearance_var = ctk.StringVar(value=self.global_settings.get("appearance_mode", "dark"))
        appearance_menu = ctk.CTkOptionMenu(
            main_frame,
            variable=appearance_var,
            values=APPEARANCE_MODES,
            width=150,
            command=lambda v: ctk.set_appearance_mode(v)  # Live preview
        )
        appearance_menu.grid(row=row, column=1, sticky="w", pady=8, padx=(10, 0))
        row += 1

        # Color theme
        ctk.CTkLabel(main_frame, text="Color:").grid(row=row, column=0, sticky="w", pady=8)
        theme_var = ctk.StringVar(value=self.global_settings.get("color_theme", "blue"))
        theme_menu = ctk.CTkOptionMenu(
            main_frame,
            variable=theme_var,
            values=COLOR_THEMES,
            width=150
        )
        theme_menu.grid(row=row, column=1, sticky="w", pady=8, padx=(10, 0))
        ctk.CTkLabel(main_frame, text="(restart required)", text_color="gray").grid(
            row=row, column=2, sticky="w", padx=5)
        row += 1

        # Font zoom
        ctk.CTkLabel(main_frame, text="Font zoom:").grid(row=row, column=0, sticky="w", pady=8)
        zoom_var = ctk.DoubleVar(value=self.global_settings.get("font_zoom", 1.0))

        zoom_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        zoom_frame.grid(row=row, column=1, columnspan=2, sticky="w", pady=8, padx=(10, 0))

        zoom_slider = ctk.CTkSlider(
            zoom_frame,
            from_=0.8,
            to=2.0,
            number_of_steps=12,
            variable=zoom_var,
            width=120
        )
        zoom_slider.pack(side="left")

        zoom_label = ctk.CTkLabel(zoom_frame, text=f"{zoom_var.get():.1f}x", width=40)
        zoom_label.pack(side="left", padx=(5, 0))

        ctk.CTkLabel(zoom_frame, text="(restart required)", text_color="gray").pack(side="left", padx=5)

        def update_zoom_label(val):
            zoom_label.configure(text=f"{float(val):.1f}x")

        zoom_slider.configure(command=update_zoom_label)
        row += 1

        # Separator
        ctk.CTkLabel(main_frame, text="").grid(row=row, column=0, pady=5)
        row += 1

        # === GIT SECTION ===
        ctk.CTkLabel(main_frame, text="Git", font=ctk.CTkFont(weight="bold")).grid(
            row=row, column=0, columnspan=3, sticky="w", pady=(0, 8))
        row += 1

        # Git binary
        ctk.CTkLabel(main_frame, text="Executable:").grid(row=row, column=0, sticky="w", pady=8)
        git_entry = ctk.CTkEntry(main_frame, width=250)
        git_entry.insert(0, self.global_settings.get("git_binary", "git"))
        git_entry.grid(row=row, column=1, sticky="ew", pady=8, padx=(10, 5))

        def browse_git():
            path = filedialog.askopenfilename(
                title="Select Git executable",
                filetypes=[("Executables", "*")]
            )
            if path:
                git_entry.delete(0, "end")
                git_entry.insert(0, path)

        ctk.CTkButton(main_frame, text="üìÇ", width=40, command=browse_git).grid(
            row=row, column=2, pady=8)
        row += 1

        # Separator
        ctk.CTkLabel(main_frame, text="").grid(row=row, column=0, pady=5)
        row += 1

        # === SECTION OPTIONS ===
        ctk.CTkLabel(main_frame, text="Options", font=ctk.CTkFont(weight="bold")).grid(
            row=row, column=0, columnspan=3, sticky="w", pady=(0, 8))
        row += 1

        # Auto-start polling
        auto_poll_var = ctk.BooleanVar(value=self.global_settings.get("auto_start_polling", False))
        ctk.CTkCheckBox(main_frame, text="Auto-start polling",
                       variable=auto_poll_var).grid(row=row, column=0, columnspan=3, sticky="w", pady=6)
        row += 1

        # Desktop notifications
        notif_var = ctk.BooleanVar(value=self.global_settings.get("desktop_notifications", True))
        ctk.CTkCheckBox(main_frame, text="Desktop notifications (notify-send)",
                       variable=notif_var).grid(row=row, column=0, columnspan=3, sticky="w", pady=6)
        row += 1

        main_frame.columnconfigure(1, weight=1)

        # Buttons
        btn_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        btn_frame.pack(fill="x", padx=15, pady=15)

        def save_settings():
            old_theme = self.global_settings.get("color_theme", "blue")
            new_theme = theme_var.get()

            self.global_settings["appearance_mode"] = appearance_var.get()
            self.global_settings["color_theme"] = new_theme
            self.global_settings["font_zoom"] = zoom_var.get()
            self.global_settings["git_binary"] = git_entry.get().strip()
            self.global_settings["auto_start_polling"] = auto_poll_var.get()
            self.global_settings["desktop_notifications"] = notif_var.get()

            try:
                save_global_settings(self.global_settings)
                if old_theme != new_theme:
                    messagebox.showinfo("Info",
                        "Settings saved.\nRestart to apply the new color theme.",
                        parent=dialog)
                else:
                    messagebox.showinfo("Info", "Settings saved.", parent=dialog)
            except Exception as e:
                messagebox.showerror("Error", f"Unable to save: {e}", parent=dialog)
                return

            dialog.destroy()

        ctk.CTkButton(btn_frame, text="Save", command=save_settings).pack(side="left", padx=5)
        ctk.CTkButton(btn_frame, text="Cancel", command=dialog.destroy).pack(side="left", padx=5)

    # --------------------------------------------------------
    # REPOS MANAGEMENT
    # --------------------------------------------------------

    def load_saved_repos(self):
        repos = load_saved_repos()
        git = self.global_settings.get("git_binary", "git")
        for repo_path in repos:
            if Path(repo_path).exists() and is_git_repo(repo_path, git):
                self.add_repo(repo_path)

        # Restore last active tab (delayed to ensure UI is ready)
        def restore_tab():
            last_tab = self.global_settings.get("last_active_tab", "")
            if last_tab and last_tab in self.tabs:
                self.switch_tab(last_tab)
            elif self.tabs:
                # Show first tab if no saved tab
                first_tab = list(self.tabs.keys())[0]
                self.switch_tab(first_tab)

        self.after(100, restore_tab)

    def save_current_repos(self):
        repos = list(self.tab_paths.values())
        save_repos(repos)

    def add_repo_dialog(self):
        path = filedialog.askdirectory(
            title="Select a Git repository",
            mustexist=True
        )
        if path:
            git = self.global_settings.get("git_binary", "git")
            if not is_git_repo(path, git):
                messagebox.showerror(
                    "Error",
                    f"'{path}' is not a valid Git repository.",
                    parent=self
                )
                return
            if path in self.tab_paths.values():
                messagebox.showinfo(
                    "Info",
                    "This repository is already open.",
                    parent=self
                )
                return

            detected = detect_repo_settings(path, git)
            config_file = Path(path) / "githerd.toml"
            if not config_file.exists():
                save_repo_config(path, detected)

            self.add_repo(path)
            self.save_current_repos()

    def add_repo(self, repo_path):
        repo_name = Path(repo_path).name

        # G√©rer les noms en double
        tab_name = repo_name
        counter = 1
        while tab_name in self.tabs:
            counter += 1
            tab_name = f"{repo_name} ({counter})"

        # Create tab button with proper height
        btn = ctk.CTkButton(
            self.tab_bar,
            text=repo_name,
            fg_color="#333333",
            hover_color="#444444",
            corner_radius=6,
            height=32,
            command=lambda n=tab_name: self.switch_tab(n)
        )
        btn.pack(side="left", padx=(0, 8), pady=8)
        self.tab_buttons[tab_name] = btn

        # Cr√©er le contenu directement dans le container
        tab_content = RepoTabContent(self.content_container, repo_path, self, tab_name)
        self.tab_frames[tab_name] = tab_content  # Store content directly

        self.tabs[tab_name] = tab_content
        self.tab_paths[tab_name] = repo_path

        # Switch to new tab
        self.switch_tab(tab_name)
        self.after(100, self.update_title)

        # Auto-start polling si activ√©
        if self.global_settings.get("auto_start_polling", False):
            self.after(500, tab_content.toggle_polling)

    def switch_tab(self, tab_name):
        """Switch to specified tab."""
        if tab_name not in self.tabs:
            return

        # Hide current tab
        if self.current_tab and self.current_tab in self.tab_frames:
            self.tab_frames[self.current_tab].pack_forget()
            # Reset previous button border
            if self.current_tab in self.tab_buttons:
                self.tab_buttons[self.current_tab].configure(border_width=0)

        # Show new tab
        self.tab_frames[tab_name].pack(fill="both", expand=True)
        self.current_tab = tab_name

        # Highlight active button
        self.tab_buttons[tab_name].configure(border_width=2, border_color="#ffffff")

        # Mark as read
        tab = self.tabs[tab_name]
        if tab.has_update:
            tab.has_update = False
            self.update_tab_color(tab)

    def close_tab(self, tab_name):
        if tab_name in self.tabs:
            tab = self.tabs[tab_name]
            tab.polling = False
            tab.stop_countdown()

            # Remove button
            if tab_name in self.tab_buttons:
                self.tab_buttons[tab_name].destroy()
                del self.tab_buttons[tab_name]

            # Remove content (tab_frames points to same object as tabs)
            if tab_name in self.tab_frames:
                del self.tab_frames[tab_name]

            # Destroy the tab content widget
            tab.destroy()
            del self.tabs[tab_name]
            del self.tab_paths[tab_name]

            # Switch to another tab if needed
            if self.current_tab == tab_name:
                self.current_tab = None
                if self.tabs:
                    first_tab = list(self.tabs.keys())[0]
                    self.switch_tab(first_tab)

            self.save_current_repos()
            self.update_title()

    # --------------------------------------------------------
    # TITLE UPDATE
    # --------------------------------------------------------

    def update_title(self):
        total = len(self.tabs)
        polling = sum(1 for t in self.tabs.values() if t.polling)
        stopped = sum(1 for t in self.tabs.values() if t.pending_branches and not t.polling)

        if total == 0:
            self.title("GitHerd")
        elif stopped > 0:
            self.title(f"GitHerd ‚Äî {total} repos, {polling} polling, {stopped} STOP")
        elif polling > 0:
            self.title(f"GitHerd ‚Äî {total} repos, {polling} polling")
        else:
            self.title(f"GitHerd ‚Äî {total} repos")

    def stop_all_polling(self):
        stopped = 0
        for tab in self.tabs.values():
            if tab.polling:
                tab.polling = False
                tab.stop_countdown()
                tab.btn_poll.configure(text="‚ñ∂ Start polling")
                self.update_tab_color(tab)
                stopped += 1

        self.update_title()

        if stopped > 0:
            self.after(100, lambda: messagebox.showinfo(
                "Polling stopped",
                f"{stopped} polling(s) stopped.",
                parent=self
            ))

    def get_current_tab(self):
        """Get the current tab content object."""
        if not self.tabs or not self.current_tab:
            return None
        return self.tabs.get(self.current_tab)

    def show_current_repo_options(self):
        """Show options for current repository."""
        tab = self.get_current_tab()
        if tab:
            tab.show_config_dialog()

    def open_current_folder(self):
        """Open current repository folder."""
        tab = self.get_current_tab()
        if tab:
            tab.open_folder()

    def close_current_tab(self):
        """Close current repository tab."""
        if not self.tabs or not self.current_tab:
            return
        self.close_tab(self.current_tab)

    def restart_app(self):
        any_sync_locked = any(tab.lock.locked() for tab in self.tabs.values())
        if any_sync_locked:
            messagebox.showwarning(
                "Sync in progress",
                "Cannot restart: a synchronization is in progress.",
                parent=self
            )
            return

        polling_count = sum(1 for tab in self.tabs.values() if tab.polling)
        if polling_count > 0:
            result = messagebox.askyesno(
                "Polling active",
                f"{polling_count} polling(s) active.\n\nStop polling and restart?",
                parent=self
            )
            if not result:
                return

            for tab in self.tabs.values():
                if tab.polling:
                    tab.polling = False
                    tab.stop_countdown()

        self.save_current_repos()

        python = sys.executable
        script = os.path.abspath(__file__)
        self.destroy()
        os.execl(python, python, script)

    def show_help(self):
        help_win = ctk.CTkToplevel(self)
        help_win.title("Help ‚Äî GitHerd")
        help_win.geometry("700x600")
        help_win.transient(self)
        help_win.grab_set()

        text = ctk.CTkTextbox(help_win, font=ctk.CTkFont(family="Consolas", size=12))
        text.pack(fill="both", expand=True, padx=10, pady=10)
        text.insert("1.0", HELP_TEXT)
        text.configure(state="disabled")

        ctk.CTkButton(help_win, text="Close", command=help_win.destroy).pack(pady=10)

    def on_close(self):
        for tab in self.tabs.values():
            tab.polling = False

        # Save last active tab
        if self.tabs and self.current_tab:
            self.global_settings["last_active_tab"] = self.current_tab
            save_global_settings(self.global_settings)

        self.save_current_repos()
        self.destroy()


# ============================================================

if __name__ == "__main__":
    apply_theme_settings()
    App().mainloop()
