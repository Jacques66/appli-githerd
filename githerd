#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GitHerd â€” Real-time Git branch synchronizer (CustomTkinter version)

Keeps multiple Git branches aligned in real-time.
Ideal for parallel AI coding sessions (Claude Code, Cursor, etc.)
or any workflow with multiple active branches.

Copyright (c) 2026 InZeMobile
Licensed under the MIT License. See LICENSE file for details.

https://github.com/Jacques66/GitHerd
"""

import subprocess
import threading
import time
import customtkinter as ctk
from tkinter import filedialog, messagebox
from pathlib import Path
from datetime import datetime
import json
import sys
import os

# ============================================================
# CONFIG & PERSISTENCE
# ============================================================

CONFIG_DIR = Path.home() / ".config" / "githerd"
REPOS_FILE = CONFIG_DIR / "repos.json"
SETTINGS_FILE = CONFIG_DIR / "settings.json"

DEFAULT_GLOBAL_SETTINGS = {
    "git_binary": "git",
    "font_zoom": 1.0,
    "auto_start_polling": False,
    "start_collapsed": False,
    "advanced_mode": False,
    "desktop_notifications": True,
    "appearance_mode": "dark",
    "color_theme": "blue",
    "last_active_tab": "",
    "restore_polling": False,  # Restaurer l'Ã©tat du polling au dÃ©marrage
    "polling_states": {},  # Ã‰tats sauvegardÃ©s (repo_path -> bool)
    "branch_update_enabled": {},  # {repo_path: {branch_name: bool}} - branches avec mises Ã  jour activÃ©es
    "sync_new_branches_by_default": False  # Activer la synchro par dÃ©faut pour les nouvelles branches dÃ©couvertes
}

APPEARANCE_MODES = ["dark", "light", "system"]
COLOR_THEMES = ["blue", "dark-blue", "green"]

DEFAULT_REPO_CONFIG = {
    "remote": "origin",
    "main_branch": "main",
    "branch_prefix": "claude/",
    "interval_seconds": 60
}

try:
    import tomllib
except ModuleNotFoundError:
    import tomli as tomllib


def load_global_settings():
    """Charge les settings globaux."""
    if SETTINGS_FILE.exists():
        try:
            with open(SETTINGS_FILE, "r") as f:
                data = json.load(f)
                settings = DEFAULT_GLOBAL_SETTINGS.copy()
                settings.update(data)
                return settings
        except Exception:
            pass
    return DEFAULT_GLOBAL_SETTINGS.copy()


def save_global_settings(settings):
    """Sauvegarde les settings globaux."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    with open(SETTINGS_FILE, "w") as f:
        json.dump(settings, f, indent=2)


def apply_theme_settings():
    """Applique les paramÃ¨tres de thÃ¨me sauvegardÃ©s au dÃ©marrage."""
    settings = load_global_settings()
    ctk.set_appearance_mode(settings.get("appearance_mode", "dark"))
    ctk.set_default_color_theme(settings.get("color_theme", "blue"))
    # Apply font/widget scaling
    font_zoom = settings.get("font_zoom", 1.0)
    ctk.set_widget_scaling(font_zoom)
    ctk.set_window_scaling(font_zoom)


def load_repo_config(repo_path):
    """Charge la config depuis githerd.toml du repo, ou utilise les valeurs par dÃ©faut."""
    config_file = Path(repo_path) / "githerd.toml"
    if config_file.exists():
        try:
            cfg = tomllib.load(open(config_file, "rb"))
            return {
                "remote": cfg.get("git", {}).get("remote", DEFAULT_REPO_CONFIG["remote"]),
                "main_branch": cfg.get("git", {}).get("main_branch", DEFAULT_REPO_CONFIG["main_branch"]),
                "branch_prefix": cfg.get("git", {}).get("branch_prefix", DEFAULT_REPO_CONFIG["branch_prefix"]),
                "interval_seconds": cfg.get("sync", {}).get("interval_seconds", DEFAULT_REPO_CONFIG["interval_seconds"])
            }
        except Exception:
            pass
    return DEFAULT_REPO_CONFIG.copy()


def save_repo_config(repo_path, config):
    """Sauvegarde la config dans githerd.toml du repo."""
    config_file = Path(repo_path) / "githerd.toml"
    toml_content = f'''[git]
remote = "{config['remote']}"
main_branch = "{config['main_branch']}"
branch_prefix = "{config['branch_prefix']}"

[sync]
interval_seconds = {config['interval_seconds']}
'''
    with open(config_file, "w") as f:
        f.write(toml_content)


def load_saved_repos():
    """Charge la liste des repos sauvegardÃ©s."""
    if REPOS_FILE.exists():
        try:
            with open(REPOS_FILE, "r") as f:
                data = json.load(f)
                return data.get("repos", [])
        except Exception:
            pass
    return []


def save_repos(repos):
    """Sauvegarde la liste des repos."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    with open(REPOS_FILE, "w") as f:
        json.dump({"repos": repos}, f, indent=2)


def detect_repo_settings(repo_path, git_binary="git"):
    """DÃ©tecte automatiquement remote et main_branch du repo."""
    settings = DEFAULT_REPO_CONFIG.copy()

    code, out, _ = run_git([git_binary, "remote"], cwd=repo_path)
    if code == 0 and out:
        remotes = out.splitlines()
        if remotes:
            settings["remote"] = remotes[0]

    remote = settings["remote"]
    code, out, _ = run_git(
        [git_binary, "symbolic-ref", f"refs/remotes/{remote}/HEAD"],
        cwd=repo_path
    )
    if code == 0 and out:
        parts = out.split("/")
        if len(parts) >= 4:
            settings["main_branch"] = parts[-1]
    else:
        code, out, _ = run_git(
            [git_binary, "branch", "-r", "--list", f"{remote}/main"],
            cwd=repo_path
        )
        if code == 0 and out.strip():
            settings["main_branch"] = "main"
        else:
            code, out, _ = run_git(
                [git_binary, "branch", "-r", "--list", f"{remote}/master"],
                cwd=repo_path
            )
            if code == 0 and out.strip():
                settings["main_branch"] = "master"

    return settings


HELP_TEXT = """GitHerd â€” Real-time Git branch synchronizer

Keeps multiple Git branches aligned in real-time.
Ideal for parallel AI coding sessions or any workflow
with multiple active branches.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

HANDLED CASES:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Situation                               â”‚ Action              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Nothing to do                           â”‚ Idle                â”‚
â”‚ Local main ahead                        â”‚ Auto push           â”‚
â”‚ Branches behind main                    â”‚ Auto push to sync   â”‚
â”‚ 1 branch ahead (not diverged)           â”‚ Fast-forward + push â”‚
â”‚ 1+ diverged branch, disjoint files      â”‚ Merge button        â”‚
â”‚ 1+ diverged branch, common files        â”‚ STOP                â”‚
â”‚ 2+ branches ahead, disjoint files       â”‚ Merge button        â”‚
â”‚ 2+ branches ahead, common files         â”‚ STOP                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

MULTI-REPO:

- File menu > Add repository (Ctrl+O)
- Each tab manages a repository independently
- Repositories are saved between sessions

TAB INDICATORS:
- Green background = Polling active
- Gray background = Polling inactive
- Red background = STOP (action required or error)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

KEYBOARD SHORTCUTS:

- Ctrl+O : Add repository
- Ctrl+S : Stop all polling
- Ctrl+R : Restart
- Ctrl+Q : Quit

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ADVANCED MODE (Settings):

When enabled, UI is simplified:
- Single click on tab: select, or toggle polling if selected
- Double click on tab: sync now (any tab)
- Buttons hidden (use menu or tab clicks)
- Log toggle next to status

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

https://github.com/Jacques66/GitHerd
"""

# ============================================================
# GIT HELPERS
# ============================================================

def run_git(cmd, cwd=None):
    try:
        p = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            cwd=cwd,
            timeout=30
        )
        return p.returncode, p.stdout.strip(), p.stderr.strip()
    except subprocess.TimeoutExpired:
        return 1, "", "Timeout"
    except FileNotFoundError:
        return 1, "", f"Command not found: {cmd[0]}"
    except Exception as e:
        return 1, "", str(e)


def commits_ahead(base, tip, cwd=None, git="git"):
    code, out, err = run_git([git, "rev-list", "--count", f"{base}..{tip}"], cwd=cwd)
    if code != 0:
        raise RuntimeError(err)
    return int(out)


def commits_behind(base, tip, cwd=None, git="git"):
    code, out, err = run_git([git, "rev-list", "--count", f"{tip}..{base}"], cwd=cwd)
    if code != 0:
        return 0
    return int(out)


def get_tracked_branches(remote, prefix, cwd=None, git="git"):
    code, out, err = run_git(
        [git, "for-each-ref", "--format=%(refname:short)",
         f"refs/remotes/{remote}/{prefix}"],
        cwd=cwd
    )
    if code != 0:
        raise RuntimeError(err)
    return out.splitlines() if out else []


def get_changed_files(base, tip, cwd=None, git="git"):
    code, out, err = run_git([git, "diff", "--name-only", f"{base}...{tip}"], cwd=cwd)
    if code != 0:
        return set()
    return set(out.splitlines()) if out else set()


def are_files_disjoint(branches, main_ref, remote, cwd=None, git="git"):
    all_files = []
    for branch in branches:
        files = get_changed_files(main_ref, f"{remote}/{branch}", cwd=cwd, git=git)
        all_files.append(files)

    for i in range(len(all_files)):
        for j in range(i + 1, len(all_files)):
            if all_files[i] & all_files[j]:
                return False
    return True


def local_main_ahead(remote, main, cwd=None, git="git"):
    try:
        return commits_ahead(f"{remote}/{main}", main, cwd=cwd, git=git)
    except:
        return 0


def delete_remote_branch(branch_name, remote, cwd=None, git="git"):
    code, out, err = run_git([git, "push", remote, "--delete", branch_name], cwd=cwd)
    return code == 0, err


def is_git_repo(path, git="git"):
    code, _, _ = run_git([git, "rev-parse", "--git-dir"], cwd=path)
    return code == 0


def check_git_health(repo_path, remote, main_branch, git="git"):
    code, _, err = run_git([git, "rev-parse", "--git-dir"], cwd=repo_path)
    if code != 0:
        return False, f"Not a Git repository: {err}"

    code, out, err = run_git([git, "remote"], cwd=repo_path)
    if code != 0:
        return False, f"Git remote error: {err}"
    if remote not in out.splitlines():
        return False, f"Remote '{remote}' not found"

    code, _, err = run_git([git, "fetch", remote, "--dry-run"], cwd=repo_path)
    if code != 0:
        return False, f"Fetch failed: {err}"

    return True, ""


# ============================================================
# SOUND & NOTIFICATIONS
# ============================================================

SOUNDS = {
    "commit": "/usr/share/sounds/freedesktop/stereo/message-new-instant.oga",
    "success": "/usr/share/sounds/freedesktop/stereo/complete.oga",
    "error": "/usr/share/sounds/freedesktop/stereo/dialog-error.oga",
    "bell": "/usr/share/sounds/freedesktop/stereo/bell.oga"
}


def play_sound(sound_type="bell"):
    sound_file = SOUNDS.get(sound_type, SOUNDS["bell"])
    try:
        subprocess.run(
            ["paplay", sound_file],
            stderr=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL
        )
    except FileNotFoundError:
        print("\a", end="", flush=True)


def send_notification(title, message, urgency="normal"):
    try:
        subprocess.run(
            ["notify-send", "-u", urgency, "-a", "GitHerd", title, message],
            stderr=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL
        )
    except FileNotFoundError:
        pass


def play_beep():
    play_sound("bell")


# ============================================================
# CUSTOM TAB BUTTON WITH INDICATOR OVERLAY
# ============================================================

import tkinter as tk


class TabButton(tk.Frame):
    """Bouton d'onglet avec indicateur en surimpression.

    L'indicateur est dessinÃ© Ã  gauche du texte centrÃ©,
    sans dÃ©caler le texte lui-mÃªme.
    Coins arrondis dessinÃ©s sur le canvas.
    """

    def __init__(self, master, text, command=None, **kwargs):
        # Extraire les paramÃ¨tres spÃ©cifiques
        self.fg_color = kwargs.pop("fg_color", "#333333")
        self.hover_color = kwargs.pop("hover_color", "#444444")
        base_corner_radius = kwargs.pop("corner_radius", 8)
        base_height = kwargs.pop("height", 32)

        self.text = text
        self.command = command
        self.indicator = ""
        self.indicator_margin = 8  # Marge entre indicateur et texte

        self._hover = False
        self._border_width = 0
        self._border_color = None

        # Obtenir le font_zoom depuis les settings globaux
        self.font_zoom = load_global_settings().get("font_zoom", 1.0)
        self.base_font_size = 13

        # Appliquer le zoom Ã  la hauteur et au rayon des coins
        self.btn_height = int(base_height * self.font_zoom)
        self.corner_radius = int(base_corner_radius * self.font_zoom)

        # Calculer la largeur: texte + espace pour indicateur + padding
        font = self._get_font()
        text_width = font.measure(text) if text else 50
        indicator_space = font.measure("â­¯") + self.indicator_margin
        padding = int(30 * self.font_zoom)  # Padding avec zoom
        self.btn_width = text_width + indicator_space + padding

        # Couleur de fond du parent (pour les coins transparents)
        try:
            self.parent_bg = master.cget("bg")
        except:
            self.parent_bg = "#2b2b2b" if ctk.get_appearance_mode() == "Dark" else "#f0f0f0"

        # Initialiser tk.Frame avec la couleur du parent (coins transparents)
        super().__init__(master, bg=self.parent_bg, height=self.btn_height, width=self.btn_width)

        # EmpÃªcher le redimensionnement automatique
        self.pack_propagate(False)

        # Canvas pour dessiner le bouton arrondi, texte et indicateur
        self.canvas = tk.Canvas(
            self,
            highlightthickness=0,
            bg=self.parent_bg,
            height=self.btn_height,
            width=self.btn_width
        )
        self.canvas.pack(fill="both", expand=True)

        # Bindings
        self.canvas.bind("<Button-1>", self._on_click)
        self.canvas.bind("<Enter>", self._on_enter)
        self.canvas.bind("<Leave>", self._on_leave)
        self.canvas.bind("<Map>", self._on_map)
        self.canvas.bind("<Configure>", self._on_configure)

    def _on_map(self, event=None):
        """AppelÃ© quand le widget devient visible."""
        self.after(50, self._draw)

    def _on_configure(self, event=None):
        """AppelÃ© quand le widget change de taille."""
        self._draw()

    def _get_font(self):
        """Retourne la police avec le zoom appliquÃ©."""
        size = int(self.base_font_size * self.font_zoom)
        return ctk.CTkFont(size=size)

    def _draw_rounded_rect(self, x1, y1, x2, y2, radius, fill, outline=""):
        """Dessine un rectangle aux coins arrondis avec des arcs."""
        r = min(radius, (x2-x1)//2, (y2-y1)//2)  # Limiter le rayon
        if r < 2:
            self.canvas.create_rectangle(x1, y1, x2, y2, fill=fill, outline=outline)
            return

        d = 2 * r  # diamÃ¨tre

        # Rectangle central horizontal
        self.canvas.create_rectangle(x1 + r, y1, x2 - r, y2, fill=fill, outline="", width=0)
        # Rectangle central vertical
        self.canvas.create_rectangle(x1, y1 + r, x2, y2 - r, fill=fill, outline="", width=0)

        # Coins arrondis avec create_arc (style=PIESLICE pour remplir)
        # Coin haut-gauche
        self.canvas.create_arc(x1, y1, x1 + d, y1 + d, start=90, extent=90, fill=fill, outline="", style="pieslice")
        # Coin haut-droit
        self.canvas.create_arc(x2 - d, y1, x2, y1 + d, start=0, extent=90, fill=fill, outline="", style="pieslice")
        # Coin bas-droit
        self.canvas.create_arc(x2 - d, y2 - d, x2, y2, start=270, extent=90, fill=fill, outline="", style="pieslice")
        # Coin bas-gauche
        self.canvas.create_arc(x1, y2 - d, x1 + d, y2, start=180, extent=90, fill=fill, outline="", style="pieslice")

    def _draw_rounded_border(self, x1, y1, x2, y2, radius, color, width):
        """Dessine une bordure arrondie (outline seulement)."""
        r = min(radius, (x2-x1)//2, (y2-y1)//2)
        if r < 2:
            self.canvas.create_rectangle(x1, y1, x2, y2, outline=color, width=width)
            return

        # Lignes droites
        # Haut
        self.canvas.create_line(x1 + r, y1, x2 - r, y1, fill=color, width=width)
        # Bas
        self.canvas.create_line(x1 + r, y2, x2 - r, y2, fill=color, width=width)
        # Gauche
        self.canvas.create_line(x1, y1 + r, x1, y2 - r, fill=color, width=width)
        # Droite
        self.canvas.create_line(x2, y1 + r, x2, y2 - r, fill=color, width=width)

        d = 2 * r
        # Coins avec arcs (style=ARC pour juste le contour)
        self.canvas.create_arc(x1, y1, x1 + d, y1 + d, start=90, extent=90, outline=color, width=width, style="arc")
        self.canvas.create_arc(x2 - d, y1, x2, y1 + d, start=0, extent=90, outline=color, width=width, style="arc")
        self.canvas.create_arc(x2 - d, y2 - d, x2, y2, start=270, extent=90, outline=color, width=width, style="arc")
        self.canvas.create_arc(x1, y2 - d, x1 + d, y2, start=180, extent=90, outline=color, width=width, style="arc")

    def _on_click(self, event=None):
        """GÃ¨re le clic."""
        if self.command:
            self.command()

    def _on_enter(self, event=None):
        """Survol - changer la couleur."""
        self._hover = True
        self._draw()

    def _on_leave(self, event=None):
        """Fin survol - restaurer la couleur."""
        self._hover = False
        self._draw()

    def _draw(self):
        """Dessine le bouton arrondi, le texte centrÃ© et l'indicateur."""
        self.canvas.delete("all")

        width = self.canvas.winfo_width()
        height = self.canvas.winfo_height()

        if width <= 1 or height <= 1:
            return

        # Couleur de fond du bouton
        bg_color = self.hover_color if self._hover else self.fg_color

        # Dessiner le rectangle arrondi (fond du bouton)
        self._draw_rounded_rect(1, 1, width - 1, height - 1, self.corner_radius, fill=bg_color)

        # Couleur du texte
        text_color = "#ffffff" if ctk.get_appearance_mode() == "Dark" else "#000000"

        font = self._get_font()

        # Calculer la largeur du texte principal
        text_width = font.measure(self.text)

        # Position Y centrÃ©e
        y_center = height // 2

        # Position X du texte centrÃ©
        x_text = width // 2

        # Dessiner le texte principal (centrÃ©)
        self.canvas.create_text(
            x_text, y_center,
            text=self.text,
            fill=text_color,
            font=font,
            anchor="center"
        )

        # Dessiner l'indicateur s'il y en a un
        if self.indicator:
            # Position: centre - (word_width/2) - marge - char_width
            char_width = font.measure(self.indicator)
            x_indicator = (width // 2) - (text_width // 2) - self.indicator_margin - (char_width // 2)

            self.canvas.create_text(
                x_indicator, y_center,
                text=self.indicator,
                fill=text_color,
                font=font,
                anchor="center"
            )

        # Dessiner la bordure arrondie si active
        if self._border_width > 0 and self._border_color:
            self._draw_rounded_border(1, 1, width - 1, height - 1, self.corner_radius, self._border_color, self._border_width)

    def configure(self, **kwargs):
        """Configure le bouton."""
        if "text" in kwargs:
            self.text = kwargs.pop("text")
        if "fg_color" in kwargs:
            self.fg_color = kwargs.pop("fg_color")
        if "hover_color" in kwargs:
            self.hover_color = kwargs.pop("hover_color")
        if "border_width" in kwargs:
            self._border_width = kwargs.pop("border_width")
        if "border_color" in kwargs:
            self._border_color = kwargs.pop("border_color")

        if kwargs:
            super().configure(**kwargs)
        self._draw()

    def set_indicator(self, indicator=""):
        """DÃ©finit l'indicateur Ã  afficher (ex: 'â­¯', 'â—', '')."""
        self.indicator = indicator
        self._draw()

    def bind(self, sequence, func, add=None):
        """Bind sur le canvas aussi."""
        super().bind(sequence, func, add)
        self.canvas.bind(sequence, func, add)

    def destroy(self):
        """DÃ©truit le widget proprement."""
        self.canvas.destroy()
        super().destroy()


# ============================================================
# REPO TAB CONTENT
# ============================================================

class RepoTabContent(ctk.CTkFrame):
    """Contenu d'un onglet gÃ©rant un seul dÃ©pÃ´t Git."""

    def __init__(self, parent, repo_path, app, tab_name):
        super().__init__(parent)

        self.repo_path = Path(repo_path)
        self.app = app
        self.tab_name = tab_name
        self.git = app.global_settings.get("git_binary", "git")

        # Charger config repo
        self.repo_config = load_repo_config(repo_path)
        self.remote = self.repo_config["remote"]
        self.main = self.repo_config["main_branch"]
        self.prefix = self.repo_config["branch_prefix"]
        self.interval = self.repo_config["interval_seconds"]

        self.lock = threading.Lock()
        self.polling = False
        self.polling_thread = None
        self.stop_event = threading.Event()
        self.log_visible = not self.app.global_settings.get("start_collapsed", False)
        self.last_commit_count = {}
        self.pending_branches = []
        self.git_healthy = True
        self.git_error = ""
        self.next_poll_time = 0
        self.countdown_job = None
        self.has_update = False
        self.syncing = False
        self.base_tab_name = Path(repo_path).name
        self.advanced_mode = self.app.global_settings.get("advanced_mode", False)

        if self.advanced_mode:
            # === MODE AVANCÃ‰ : Layout compact ===
            # Frame combinÃ© : Log button Ã  gauche, status Ã  droite
            combined_frame = ctk.CTkFrame(self, fg_color="transparent")
            combined_frame.pack(fill="x", padx=10, pady=6)

            # Log toggle Ã  gauche
            self.btn_toggle_log = ctk.CTkButton(
                combined_frame,
                text="â–¼ Log" if self.log_visible else "â–¶ Log",
                width=70,
                command=self.toggle_log
            )
            self.btn_toggle_log.pack(side="left", padx=(0, 15))

            # Status Ã  droite
            status_frame = ctk.CTkFrame(combined_frame, fg_color="transparent")
            status_frame.pack(side="left", fill="x", expand=True)

            self.state_label = ctk.CTkLabel(
                status_frame,
                text="Startingâ€¦",
                font=ctk.CTkFont(size=16, weight="bold")
            )
            self.state_label.pack(anchor="w")

            info_frame = ctk.CTkFrame(status_frame, fg_color="transparent")
            info_frame.pack(anchor="w", fill="x")

            self.info_label = ctk.CTkLabel(
                info_frame,
                text="Analyzingâ€¦",
                font=ctk.CTkFont(size=13),
                wraplength=500
            )
            self.info_label.pack(side="left")

            self.countdown_label = ctk.CTkLabel(
                info_frame,
                text="",
                font=ctk.CTkFont(size=13),
                text_color="gray"
            )
            self.countdown_label.pack(side="left", padx=10)

            # Pas de buttons_frame en mode avancÃ©, mais on crÃ©e les boutons cachÃ©s
            self.buttons_frame = ctk.CTkFrame(self, fg_color="transparent")
            # Ne pas pack

            self.btn_poll = ctk.CTkButton(self.buttons_frame, text="", width=1)
            self.btn_sync = ctk.CTkButton(self.buttons_frame, text="", width=1)
            self.btn_config = ctk.CTkButton(self.buttons_frame, text="", width=1)
            self.btn_close = ctk.CTkButton(self.buttons_frame, text="", width=1)
            self.btn_merge = ctk.CTkButton(
                self.buttons_frame,
                text="ğŸ”€ Merge",
                command=self.manual_merge,
                width=100,
                fg_color="#DAA520",
                hover_color="#B8860B"
            )
        else:
            # === MODE NORMAL : Layout complet ===
            # TOP BAR (status)
            top_bar = ctk.CTkFrame(self)
            top_bar.pack(fill="x", padx=10, pady=6)

            self.state_label = ctk.CTkLabel(
                top_bar,
                text="Startingâ€¦",
                font=ctk.CTkFont(size=16, weight="bold")
            )
            self.state_label.pack(anchor="w", padx=5)

            # Info + countdown
            info_frame = ctk.CTkFrame(top_bar, fg_color="transparent")
            info_frame.pack(anchor="w", fill="x")

            self.info_label = ctk.CTkLabel(
                info_frame,
                text="Analyzingâ€¦",
                font=ctk.CTkFont(size=13),
                wraplength=600
            )
            self.info_label.pack(side="left", padx=5)

            self.countdown_label = ctk.CTkLabel(
                info_frame,
                text="",
                font=ctk.CTkFont(size=13),
                text_color="gray"
            )
            self.countdown_label.pack(side="left", padx=10)

            # BUTTONS (with log toggle at start)
            self.buttons_frame = ctk.CTkFrame(self, fg_color="transparent")
            self.buttons_frame.pack(fill="x", padx=10, pady=8)

            # Log toggle at the beginning
            self.btn_toggle_log = ctk.CTkButton(
                self.buttons_frame,
                text="â–¼ Log" if self.log_visible else "â–¶ Log",
                width=70,
                command=self.toggle_log
            )
            self.btn_toggle_log.pack(side="left", padx=(0, 10))

            self.btn_poll = ctk.CTkButton(
                self.buttons_frame,
                text="â–¶ Start polling",
                command=self.toggle_polling,
                width=140
            )
            self.btn_poll.pack(side="left", padx=6)

            self.btn_sync = ctk.CTkButton(
                self.buttons_frame,
                text="âš¡ Sync now",
                command=self.manual_sync,
                width=120
            )
            self.btn_sync.pack(side="left", padx=6)

            self.btn_merge = ctk.CTkButton(
                self.buttons_frame,
                text="ğŸ”€ Merge",
                command=self.manual_merge,
                width=100,
                fg_color="#DAA520",
                hover_color="#B8860B"
            )
            # CachÃ© par dÃ©faut

            self.btn_config = ctk.CTkButton(
                self.buttons_frame,
                text="âš™ Options",
                command=self.show_config_dialog,
                width=100
            )
            self.btn_config.pack(side="right", padx=6)

            self.btn_close = ctk.CTkButton(
                self.buttons_frame,
                text="âœ• Close",
                command=lambda: self.app.close_tab(self.tab_name),
                width=100,
                fg_color="#8B0000",
                hover_color="#CD5C5C"
            )
            self.btn_close.pack(side="right", padx=6)

        # LOG TEXTBOX
        self.log_frame = ctk.CTkFrame(self, fg_color="transparent")
        if self.log_visible:
            self.log_frame.pack(fill="both", expand=True, padx=10, pady=6)

        self.log = ctk.CTkTextbox(
            self.log_frame,
            font=ctk.CTkFont(family="Consolas", size=12),
            height=250,
            state="disabled"
        )
        self.log.pack(fill="both", expand=True)

        # DÃ‰MARRAGE
        threading.Thread(target=self.initial_scan, daemon=True).start()

    # --------------------------------------------------------
    # GIT HEALTH & TAB STATE
    # --------------------------------------------------------

    def check_and_update_health(self):
        ok, err = check_git_health(self.repo_path, self.remote, self.main, self.git)
        self.git_healthy = ok
        self.git_error = err

        if not ok:
            self.disable_tab(err)
        else:
            self.enable_tab()

        return ok

    def disable_tab(self, error_msg):
        self.state_label.configure(text="ERROR â€” Git not working")
        self.info_label.configure(text=error_msg)
        self.btn_poll.configure(state="disabled")
        self.btn_sync.configure(state="disabled")
        self.polling = False
        self.btn_poll.configure(text="â–¶ Start polling")
        self.after(0, lambda: self.app.update_tab_color(self))

    def enable_tab(self):
        self.btn_poll.configure(state="normal")
        self.btn_sync.configure(state="normal")

    # --------------------------------------------------------
    # CONFIG DIALOG
    # --------------------------------------------------------

    def show_config_dialog(self):
        dialog = ctk.CTkToplevel(self.app)
        dialog.title(f"Options â€” {self.repo_path.name}")
        dialog.geometry("450x380")
        dialog.transient(self.app)
        dialog.resizable(False, False)
        self.app.ensure_dialog_on_screen(dialog)

        # Main frame with internal padding
        main_frame = ctk.CTkFrame(dialog)
        main_frame.pack(fill="both", expand=True, padx=15, pady=15)

        # Section title
        ctk.CTkLabel(main_frame, text="Repository settings",
                    font=ctk.CTkFont(weight="bold")).grid(
            row=0, column=0, columnspan=2, sticky="w", padx=15, pady=(15, 10))

        # Remote
        ctk.CTkLabel(main_frame, text="Remote:").grid(
            row=1, column=0, sticky="w", padx=15, pady=8)
        remote_entry = ctk.CTkEntry(main_frame, width=250)
        remote_entry.insert(0, self.remote)
        remote_entry.grid(row=1, column=1, sticky="ew", padx=(10, 15), pady=8)

        # Main branch
        ctk.CTkLabel(main_frame, text="Main branch:").grid(
            row=2, column=0, sticky="w", padx=15, pady=8)
        main_entry = ctk.CTkEntry(main_frame, width=250)
        main_entry.insert(0, self.main)
        main_entry.grid(row=2, column=1, sticky="ew", padx=(10, 15), pady=8)

        # Branch prefix
        ctk.CTkLabel(main_frame, text="Branch prefix:").grid(
            row=3, column=0, sticky="w", padx=15, pady=8)
        prefix_entry = ctk.CTkEntry(main_frame, width=250)
        prefix_entry.insert(0, self.prefix)
        prefix_entry.grid(row=3, column=1, sticky="ew", padx=(10, 15), pady=8)

        # Interval
        ctk.CTkLabel(main_frame, text="Interval (sec):").grid(
            row=4, column=0, sticky="w", padx=15, pady=8)
        interval_entry = ctk.CTkEntry(main_frame, width=100)
        interval_entry.insert(0, str(self.interval))
        interval_entry.grid(row=4, column=1, sticky="w", padx=(10, 15), pady=8)

        main_frame.columnconfigure(1, weight=1)

        # Buttons
        btn_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        btn_frame.pack(fill="x", padx=15, pady=15)

        def save_config():
            self.remote = remote_entry.get().strip()
            self.main = main_entry.get().strip()
            self.prefix = prefix_entry.get().strip()
            try:
                self.interval = int(interval_entry.get().strip())
            except ValueError:
                self.interval = 60

            self.repo_config = {
                "remote": self.remote,
                "main_branch": self.main,
                "branch_prefix": self.prefix,
                "interval_seconds": self.interval
            }

            try:
                save_repo_config(self.repo_path, self.repo_config)
                self.log_msg("Configuration saved")
                self.check_and_update_health()
            except Exception as e:
                messagebox.showerror("Error", f"Unable to save: {e}", parent=dialog)
                return

            dialog.destroy()

        ctk.CTkButton(btn_frame, text="Save", command=save_config).pack(side="left", padx=5)
        ctk.CTkButton(btn_frame, text="Cancel", command=dialog.destroy).pack(side="left", padx=5)

        # Grab focus after widgets are created
        dialog.wait_visibility()
        dialog.grab_set()

    def open_folder(self):
        try:
            subprocess.run(["xdg-open", str(self.repo_path)],
                          stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)
        except:
            pass

    def delete_branch(self, branch_name):
        # Skip confirmation in advanced mode
        if not self.app.global_settings.get("advanced_mode", False):
            if not messagebox.askyesno(
                "Confirm deletion",
                f"Delete remote branch '{branch_name}'?\n\nThis action is irreversible.",
                parent=self
            ):
                return

        self.log_msg(f"Deleting {branch_name}â€¦")
        success, err = delete_remote_branch(branch_name, self.remote,
                                           cwd=self.repo_path, git=self.git)

        if success:
            self.log_msg(f"Branch {branch_name} deleted")
            self.app.update_repo_menu()
            self.manual_sync()
        else:
            self.log_msg(f"Error: {err}")

    # --------------------------------------------------------
    # TOGGLE LOG
    # --------------------------------------------------------

    def toggle_log(self):
        # Force geometry update and get position BEFORE any changes
        self.app.update_idletasks()
        geo = self.app.geometry()
        # Parse "WIDTHxHEIGHT+X+Y" format and extract X and Y separately
        import re
        match = re.match(r'(\d+)x(\d+)\+(\d+)\+(\d+)', geo)
        if match:
            x, y = match.group(3), match.group(4)
        else:
            x, y = 100, 100

        # Hauteur collapsed: 189px normal, 151px avancÃ©
        collapsed_height = 151 if self.advanced_mode else 189

        if self.log_visible:
            self.log_frame.pack_forget()
            self.btn_toggle_log.configure(text="â–¶ Log")
            self.app.geometry(f"710x{collapsed_height}+{x}+{y}")
        else:
            self.log_frame.pack(fill="both", expand=True, padx=10, pady=6)
            self.btn_toggle_log.configure(text="â–¼ Log")
            self.app.geometry(f"710x750+{x}+{y}")
        self.log_visible = not self.log_visible

    # --------------------------------------------------------
    # MERGE BUTTON VISIBILITY
    # --------------------------------------------------------

    def show_merge_button(self):
        self.btn_merge.pack(side="left", padx=6)

    def hide_merge_button(self):
        self.btn_merge.pack_forget()

    # --------------------------------------------------------
    # POLLING CONTROL
    # --------------------------------------------------------

    def stop_polling(self):
        self.polling = False
        self.btn_poll.configure(text="â–¶ Start polling")
        self.stop_countdown()
        self.after(0, lambda: self.app.update_tab_color(self))

    def _mark_if_not_active(self):
        try:
            if self.app.current_tab != self.tab_name:
                self.app.mark_tab_updated(self)
        except Exception:
            pass

    # --------------------------------------------------------
    # LOGGING
    # --------------------------------------------------------

    def log_msg(self, txt):
        ts = datetime.now().strftime("%H:%M:%S")
        self.log.configure(state="normal")
        self.log.insert("end", f"[{ts}] {txt}\n")
        self.log.see("end")
        self.log.configure(state="disabled")

    def export_log(self):
        filename = filedialog.asksaveasfilename(
            title="Export log",
            defaultextension=".txt",
            initialfile=f"githerd-{self.repo_path.name}-{datetime.now().strftime('%Y%m%d-%H%M%S')}.txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        if filename:
            try:
                content = self.log.get("1.0", "end")
                with open(filename, "w") as f:
                    f.write(f"GitHerd Log - {self.repo_path}\n")
                    f.write(f"Exported: {datetime.now()}\n")
                    f.write("=" * 50 + "\n\n")
                    f.write(content)
                self.log_msg(f"Log exported to {filename}")
            except Exception as e:
                messagebox.showerror("Error", f"Unable to export: {e}", parent=self)

    # --------------------------------------------------------
    # COUNTDOWN
    # --------------------------------------------------------

    def start_countdown(self):
        self.update_countdown()

    def stop_countdown(self):
        if self.countdown_job:
            self.after_cancel(self.countdown_job)
            self.countdown_job = None
        self.countdown_label.configure(text="")

    def update_countdown(self):
        if not self.polling:
            self.countdown_label.configure(text="")
            return

        remaining = int(self.next_poll_time - time.time())
        if remaining > 0:
            self.countdown_label.configure(text=f"(next sync: {remaining}s)")
        else:
            self.countdown_label.configure(text="(sync...)")

        self.countdown_job = self.after(1000, self.update_countdown)

    # --------------------------------------------------------
    # PUSH ALL BRANCHES
    # --------------------------------------------------------

    def push_main_and_branches(self):
        self.log_msg(f"git push {self.remote} {self.main}")
        code, out, err = run_git([self.git, "push", self.remote, self.main],
                                cwd=self.repo_path)
        if code != 0:
            self.log_msg(f"ERROR push main: {err}")
            self.state_label.configure(text="ERROR")
            self.stop_polling()
            return False
        self.log_msg(out if out else "  (ok)")

        all_branches = get_tracked_branches(self.remote, self.prefix,
                                            cwd=self.repo_path, git=self.git)

        # Filter out disabled branches
        settings = load_global_settings()
        branch_states = settings.get("branch_update_enabled", {}).get(str(self.repo_path), {})
        default_enabled = settings.get("sync_new_branches_by_default", False)

        for b in all_branches:
            target = b.replace(f"{self.remote}/", "")
            # Skip disabled branches
            if not branch_states.get(target, default_enabled):
                self.log_msg(f"  {target}: skipped (sync disabled)")
                continue
            refspec = f"{self.main}:{target}"
            self.log_msg(f"git push {self.remote} {refspec}")
            code, out, err = run_git([self.git, "push", self.remote, refspec],
                                    cwd=self.repo_path)
            if code != 0:
                self.log_msg(f"ERROR push {target}: {err}")
                self.state_label.configure(text="STOP â€” Push failed")
                self.info_label.configure(text=f"Push to {target} failed")
                self.stop_polling()
                return False
            self.log_msg(out if out else "  (ok)")

        return True

    # --------------------------------------------------------
    # CORE LOGIC
    # --------------------------------------------------------

    def sync(self):
        if not self.lock.acquire(blocking=False):
            return
        try:
            # Afficher l'indicateur de sync sur l'onglet
            self.syncing = True
            self.after(0, lambda: self.app.update_tab_color(self))
            self._do_sync()
        finally:
            # Masquer l'indicateur de sync
            self.syncing = False
            self.after(0, lambda: self.app.update_tab_color(self))
            # Mettre Ã  jour le menu Repository si cet onglet est actif
            self.after(0, lambda: self.app.update_repo_menu() if self.app.get_current_tab() == self else None)
            self.lock.release()

    def _do_sync(self):
        self.state_label.configure(text="Syncâ€¦")
        self.hide_merge_button()
        self.pending_branches = []

        self.log_msg(f"git fetch {self.remote}")
        code, _, err = run_git([self.git, "fetch", self.remote], cwd=self.repo_path)
        if code != 0:
            self.log_msg(f"ERROR fetch: {err}")
            self.state_label.configure(text="ERROR")
            self.stop_polling()
            return

        local_ahead = local_main_ahead(self.remote, self.main,
                                       cwd=self.repo_path, git=self.git)
        if local_ahead > 0:
            self.log_msg(f"Local main ahead by {local_ahead} commits â†’ push")
            if self.push_main_and_branches():
                self.state_label.configure(text="Sync OK")
                self.info_label.configure(text=f"Pushed {local_ahead} local commits")
                self.log_msg("Push completed successfully")
            return

        all_branches = get_tracked_branches(self.remote, self.prefix,
                                        cwd=self.repo_path, git=self.git)

        # Filter out disabled branches
        settings = load_global_settings()
        branch_states = settings.get("branch_update_enabled", {}).get(str(self.repo_path), {})
        default_enabled = settings.get("sync_new_branches_by_default", False)
        branches = []
        disabled_count = 0
        for b in all_branches:
            short_name = b.replace(f"{self.remote}/", "")
            if branch_states.get(short_name, default_enabled):
                branches.append(b)
            else:
                disabled_count += 1

        # Clean up non-existent branches from persistence
        existing_short_names = {b.replace(f"{self.remote}/", "") for b in all_branches}
        repo_path_str = str(self.repo_path)
        if repo_path_str in settings.get("branch_update_enabled", {}):
            saved_branches = list(settings["branch_update_enabled"][repo_path_str].keys())
            cleaned = False
            for saved_branch in saved_branches:
                if saved_branch not in existing_short_names:
                    del settings["branch_update_enabled"][repo_path_str][saved_branch]
                    cleaned = True
            if cleaned:
                save_global_settings(settings)

        if disabled_count > 0:
            self.log_msg(f"Branches {self.prefix}*: {len(all_branches)} ({disabled_count} disabled)")
        else:
            self.log_msg(f"Branches {self.prefix}*: {len(all_branches)}")

        ahead_branches = []
        diverged_branches = []
        new_commits_detected = False

        for b in branches:
            ahead = commits_ahead(f"{self.remote}/{self.main}", b,
                                 cwd=self.repo_path, git=self.git)
            behind = commits_behind(f"{self.remote}/{self.main}", b,
                                   cwd=self.repo_path, git=self.git)

            if ahead > 0:
                short_name = b.replace(f"{self.remote}/", "")

                if behind > 0:
                    diverged_branches.append((short_name, ahead, behind))
                    self.log_msg(f"  {short_name}: +{ahead}/-{behind} (DIVERGED)")
                else:
                    ahead_branches.append((short_name, ahead))
                    self.log_msg(f"  {short_name}: +{ahead} commits")

                prev = self.last_commit_count.get(short_name, 0)
                if ahead > prev:
                    new_commits_detected = True
                self.last_commit_count[short_name] = ahead

        if new_commits_detected:
            self.log_msg("New commit detected!")
            threading.Thread(target=lambda: play_sound("commit"), daemon=True).start()
            if self.app.global_settings.get("desktop_notifications", True):
                send_notification(
                    f"GitHerd â€” {self.repo_path.name}",
                    "New commit detected!",
                    "normal"
                )
            self.after(0, self._mark_if_not_active)

        total_problematic = len(ahead_branches) + len(diverged_branches)

        if total_problematic == 0:
            behind_branches = []
            for b in branches:
                behind = commits_behind(f"{self.remote}/{self.main}", b,
                                       cwd=self.repo_path, git=self.git)
                if behind > 0:
                    short_name = b.replace(f"{self.remote}/", "")
                    behind_branches.append((short_name, behind))
                    self.log_msg(f"  {short_name}: -{behind} commits (behind)")

            if behind_branches:
                self.log_msg(f"Synchronizing {len(behind_branches)} branches behindâ€¦")
                for branch_name, _ in behind_branches:
                    refspec = f"{self.main}:{branch_name}"
                    self.log_msg(f"git push {self.remote} {refspec}")
                    code, out, err = run_git(
                        [self.git, "push", self.remote, refspec],
                        cwd=self.repo_path
                    )
                    if code != 0:
                        self.log_msg(f"ERROR push {branch_name}: {err}")
                        self.state_label.configure(text="ERROR")
                        self.stop_polling()
                        return
                    self.log_msg(out if out else "  (ok)")

                self.state_label.configure(text="Sync OK")
                self.info_label.configure(text=f"{len(behind_branches)} branches synchronized")
                self.log_msg("Behind branches synchronized")
                return

            self.state_label.configure(text="Idle")
            self.info_label.configure(text="All branches are synchronized")
            self.log_msg("Nothing to do")
            self.last_commit_count.clear()
            return

        if len(diverged_branches) > 0 or len(ahead_branches) > 1:
            all_names = [b[0] for b in diverged_branches] + [b[0] for b in ahead_branches]
            self.pending_branches = all_names

            self.log_msg("Checking modified filesâ€¦")
            disjoint = are_files_disjoint(all_names, f"{self.remote}/{self.main}",
                                         self.remote, cwd=self.repo_path, git=self.git)

            if len(diverged_branches) > 0:
                diverged_names = [f"{b[0]} (+{b[1]}/-{b[2]})" for b in diverged_branches]
                msg = f"Diverged branches: {', '.join(diverged_names)}"
            else:
                msg = f"Multiple branches: {', '.join(all_names)}"

            if disjoint:
                self.state_label.configure(text="STOP â€” Merge possible")
                self.info_label.configure(text=f"Disjoint files. {msg}")
                self.log_msg("Disjoint files â€” manual merge possible")
                self.show_merge_button()
            else:
                self.state_label.configure(text="STOP â€” Human action required")
                self.info_label.configure(text=f"Potential file conflict. {msg}")
                self.log_msg("STOP: common files detected")
            self.stop_polling()
            return

        leader, _ = ahead_branches[0]
        self.log_msg(f"git pull --ff-only {self.remote} {leader}")
        code, out, err = run_git(
            [self.git, "pull", "--ff-only", self.remote, leader],
            cwd=self.repo_path
        )
        if code != 0:
            self.log_msg(f"ERROR pull: {err}")
            self.state_label.configure(text="ERROR")
            self.info_label.configure(text=f"Pull failed: {err[:100]}")
            self.stop_polling()
            return
        self.log_msg(out if out else "  (ok)")

        if not self.push_main_and_branches():
            return

        self.last_commit_count[leader] = 0
        self.state_label.configure(text="Sync OK")
        branches = get_tracked_branches(self.remote, self.prefix,
                                        cwd=self.repo_path, git=self.git)
        other_count = len(branches) - 1
        self.info_label.configure(text=f"Pull from {leader}, push to {other_count} other branches")
        self.log_msg("Sync completed successfully")

    # --------------------------------------------------------
    # MANUAL MERGE
    # --------------------------------------------------------

    def manual_merge(self):
        threading.Thread(target=self._do_merge, daemon=True).start()

    def _do_merge(self):
        if not self.lock.acquire(blocking=False):
            return
        try:
            self._do_merge_impl()
        finally:
            self.lock.release()

    def _do_merge_impl(self):
        if not self.pending_branches:
            self.log_msg("No branches pending merge")
            return

        self.state_label.configure(text="Mergingâ€¦")
        self.hide_merge_button()

        branches = self.pending_branches[:]
        self.log_msg(f"Merging {len(branches)} branches: {', '.join(branches)}")

        for branch in branches:
            self.log_msg(f"git merge {self.remote}/{branch}")
            code, out, err = run_git(
                [self.git, "merge", f"{self.remote}/{branch}", "-m", f"Merge {branch}"],
                cwd=self.repo_path
            )
            if code != 0:
                self.log_msg(f"ERROR merge {branch}: {err}")
                self.state_label.configure(text="ERROR â€” Merge failed")
                self.info_label.configure(text=f"Merge of {branch} failed")
                run_git([self.git, "merge", "--abort"], cwd=self.repo_path)
                self.stop_polling()
                return
            self.log_msg(out if out else "  (ok)")

        if not self.push_main_and_branches():
            return

        self.pending_branches = []
        self.last_commit_count.clear()
        self.state_label.configure(text="Merge OK")
        self.info_label.configure(text=f"Merged {len(branches)} branches")
        self.log_msg("Merge completed successfully")

        self.after(0, lambda: self.app.update_tab_color(self))

    # --------------------------------------------------------
    # INITIAL SCAN
    # --------------------------------------------------------

    def initial_scan(self):
        if not self.check_and_update_health():
            self.log_msg(f"Error: {self.git_error}")
            return

        try:
            run_git([self.git, "fetch", self.remote], cwd=self.repo_path)

            local_ahead = local_main_ahead(self.remote, self.main,
                                          cwd=self.repo_path, git=self.git)
            if local_ahead > 0:
                self.state_label.configure(text="Local main ahead")
                self.info_label.configure(text=f"+{local_ahead} commits to push â€” click Sync now")
                return

            branches = get_tracked_branches(self.remote, self.prefix,
                                           cwd=self.repo_path, git=self.git)

            ahead_list = []
            diverged_list = []

            for b in branches:
                ahead = commits_ahead(f"{self.remote}/{self.main}", b,
                                     cwd=self.repo_path, git=self.git)
                behind = commits_behind(f"{self.remote}/{self.main}", b,
                                       cwd=self.repo_path, git=self.git)

                if ahead > 0:
                    short_name = b.replace(f"{self.remote}/", "")
                    self.last_commit_count[short_name] = ahead

                    if behind > 0:
                        diverged_list.append((short_name, ahead, behind))
                    else:
                        ahead_list.append(short_name)

            total = len(ahead_list) + len(diverged_list)

            if total == 0:
                behind_list = []
                for b in branches:
                    behind = commits_behind(f"{self.remote}/{self.main}", b,
                                           cwd=self.repo_path, git=self.git)
                    if behind > 0:
                        short_name = b.replace(f"{self.remote}/", "")
                        behind_list.append((short_name, behind))

                if behind_list:
                    names = [f"{b[0]} (-{b[1]})" for b in behind_list]
                    self.state_label.configure(text="Branches behind")
                    self.info_label.configure(text=f"To synchronize: {', '.join(names)}")
                else:
                    self.state_label.configure(text="Idle")
                    self.info_label.configure(text="All branches are synchronized")
            elif len(diverged_list) == 0 and len(ahead_list) == 1:
                self.state_label.configure(text="1 branch ahead")
                self.info_label.configure(text=f"Ready to sync: {ahead_list[0]}")
            else:
                all_names = [b[0] for b in diverged_list] + ahead_list
                self.pending_branches = all_names

                disjoint = are_files_disjoint(all_names, f"{self.remote}/{self.main}",
                                             self.remote, cwd=self.repo_path, git=self.git)

                if len(diverged_list) > 0:
                    diverged_info = [f"{b[0]} (+{b[1]}/-{b[2]})" for b in diverged_list]
                    msg = f"Diverged: {', '.join(diverged_info)}"
                else:
                    msg = f"Multiple branches: {', '.join(all_names)}"

                if disjoint:
                    self.state_label.configure(text="STOP â€” Merge possible")
                    self.info_label.configure(text=f"Disjoint files. {msg}")
                    self.after(100, self.show_merge_button)
                else:
                    self.state_label.configure(text="STOP â€” Human action required")
                    self.info_label.configure(text=msg)

                self.after(0, lambda: self.app.update_tab_color(self))

        except Exception as e:
            self.state_label.configure(text="ERROR")
            self.info_label.configure(text=str(e))
            self.after(0, lambda: self.app.update_tab_color(self))

    # --------------------------------------------------------
    # POLLING
    # --------------------------------------------------------

    def polling_loop(self):
        """Boucle de polling dans son propre thread.

        Utilise stop_event pour un arrÃªt propre :
        - Le thread attend soit le timeout, soit le signal d'arrÃªt
        - Le sync en cours se termine toujours avant l'arrÃªt
        """
        while not self.stop_event.is_set():
            self.sync()  # Bloquant - se termine avant de vÃ©rifier stop_event

            # Recharger l'intervalle (peut avoir changÃ©)
            try:
                cfg = load_repo_config(self.repo_path)
                interval = cfg.get("interval_seconds", self.interval)
            except:
                interval = self.interval

            self.next_poll_time = time.time() + interval

            # Attendre l'intervalle OU le signal d'arrÃªt
            # wait() retourne True si l'event est set, False si timeout
            if self.stop_event.wait(timeout=interval):
                break  # Signal d'arrÃªt reÃ§u

    def toggle_polling(self):
        if not self.git_healthy:
            return

        if self.polling:
            # ArrÃªter le polling
            self.polling = False
            self.stop_event.set()  # Signal au thread de s'arrÃªter
            self.btn_poll.configure(text="â–¶ Start polling")
            self.stop_countdown()
        else:
            # DÃ©marrer le polling
            self.polling = True
            self.stop_event.clear()  # Reset l'event
            self.btn_poll.configure(text="â¸ Stop polling")
            self.next_poll_time = time.time() + self.interval
            self.start_countdown()
            self.polling_thread = threading.Thread(
                target=self.polling_loop,
                daemon=True,
                name=f"polling-{self.tab_name}"
            )
            self.polling_thread.start()

        self.app.update_tab_color(self)
        self.app.update_title()

    def wait_for_polling_thread(self, timeout=None):
        """Attend la fin du thread de polling.

        Args:
            timeout: Temps max d'attente en secondes (None = infini)
        Returns:
            True si le thread s'est arrÃªtÃ©, False si timeout
        """
        if self.polling_thread and self.polling_thread.is_alive():
            self.polling_thread.join(timeout=timeout)
            return not self.polling_thread.is_alive()
        return True

    def manual_sync(self):
        if not self.git_healthy:
            return
        threading.Thread(target=self.sync, daemon=True).start()


# ============================================================
# MAIN APP
# ============================================================

class App(ctk.CTk):
    def __init__(self):
        super().__init__()

        # Cacher la fenÃªtre pendant l'initialisation
        self.withdraw()

        self.tabs = {}  # tab_name -> RepoTabContent
        self.tab_paths = {}  # tab_name -> repo_path
        self.global_settings = load_global_settings()

        self.title("GitHerd")
        if self.global_settings.get("start_collapsed", False):
            # Hauteur collapsed: 189px normal, 151px avancÃ©
            advanced_mode = self.global_settings.get("advanced_mode", False)
            collapsed_height = 151 if advanced_mode else 189
            self.geometry(f"710x{collapsed_height}")
        else:
            self.geometry("710x750")

        # Restaurer la position de la fenÃªtre si sauvegardÃ©e (aprÃ¨s restart)
        saved_x = self.global_settings.get("window_x")
        saved_y = self.global_settings.get("window_y")
        if saved_x is not None and saved_y is not None:
            self.geometry(f"+{saved_x}+{saved_y}")
            # Nettoyer les valeurs aprÃ¨s utilisation (seulement pour restart)
            del self.global_settings["window_x"]
            del self.global_settings["window_y"]
            save_global_settings(self.global_settings)

        # MENU BAR
        import tkinter as tk
        import tkinter.font as tkfont

        # Calculate menu font size based on font_zoom
        font_zoom = self.global_settings.get("font_zoom", 1.0)
        menu_font_size = int(10 * font_zoom)
        menu_font = tkfont.Font(family="sans-serif", size=menu_font_size)

        # Couleurs selon le mode d'apparence
        appearance = self.global_settings.get("appearance_mode", "dark")
        if appearance == "dark" or (appearance == "system" and ctk.get_appearance_mode() == "Dark"):
            menu_bg = "#2b2b2b"
            menu_fg = "#ffffff"
            menu_active_bg = "#404040"
            menu_active_fg = "#ffffff"
        else:
            menu_bg = "#f0f0f0"
            menu_fg = "#000000"
            menu_active_bg = "#0078d4"
            menu_active_fg = "#ffffff"

        self.menubar = tk.Menu(self, font=menu_font, bg=menu_bg, fg=menu_fg,
                               activebackground=menu_active_bg, activeforeground=menu_active_fg)
        self.config(menu=self.menubar)

        # File menu
        file_menu = tk.Menu(self.menubar, tearoff=0, font=menu_font, bg=menu_bg, fg=menu_fg,
                           activebackground=menu_active_bg, activeforeground=menu_active_fg)
        self.menubar.add_cascade(label="\u00a0\u00a0\u00a0File\u00a0\u00a0\u00a0", menu=file_menu)
        file_menu.add_command(label="Add repository...", command=self.add_repo_dialog,
                             accelerator="Ctrl+O")
        file_menu.add_command(label="Stop all polling", command=self.stop_all_polling,
                             accelerator="Ctrl+S")
        file_menu.add_separator()
        file_menu.add_command(label="Restart", command=self.restart_app,
                             accelerator="Ctrl+R")
        file_menu.add_command(label="Quit", command=self.on_close, accelerator="Ctrl+Q")

        # Repository menu (dynamically updated)
        self.repo_menu = tk.Menu(self.menubar, tearoff=0, font=menu_font, bg=menu_bg, fg=menu_fg,
                                activebackground=menu_active_bg, activeforeground=menu_active_fg)
        self.menu_font = menu_font  # Save for update_repo_menu
        self.menu_colors = {"bg": menu_bg, "fg": menu_fg, "active_bg": menu_active_bg, "active_fg": menu_active_fg}
        self.menubar.add_cascade(label="\u00a0\u00a0\u00a0Repository\u00a0\u00a0\u00a0", menu=self.repo_menu)

        # ? menu (Options + Help)
        help_menu = tk.Menu(self.menubar, tearoff=0, font=menu_font, bg=menu_bg, fg=menu_fg,
                           activebackground=menu_active_bg, activeforeground=menu_active_fg)
        self.menubar.add_cascade(label="\u00a0\u00a0\u00a0?\u00a0\u00a0\u00a0", menu=help_menu)
        help_menu.add_command(label="Settings...", command=self.show_global_settings)
        help_menu.add_separator()
        help_menu.add_command(label="Help", command=self.show_help)
        help_menu.add_command(label="About GitHerd", command=self.show_about)

        # Raccourcis clavier
        self.bind("<Control-o>", lambda e: self.add_repo_dialog())
        self.bind("<Control-s>", lambda e: self.stop_all_polling())
        self.bind("<Control-r>", lambda e: self.restart_app())
        self.bind("<Control-q>", lambda e: self.on_close())

        # CUSTOM TAB BAR (left-aligned with colors)
        self.tab_bar = ctk.CTkFrame(self, height=40)
        self.tab_bar.pack(fill="x", padx=10, pady=(10, 0))

        # Container for tab content
        self.content_container = ctk.CTkFrame(self)
        self.content_container.pack(fill="both", expand=True, padx=10, pady=(5, 10))

        # Tab buttons dict: tab_name -> CTkButton
        self.tab_buttons = {}
        # Tab frames dict: tab_name -> CTkFrame (content)
        self.tab_frames = {}
        # Current active tab
        self.current_tab = None

        # Charger les repos sauvegardÃ©s
        self.load_saved_repos()

        # Si aucun repo, ouvrir le dialogue
        if not self.tabs:
            self.after(100, self.add_repo_dialog)

        # Sauvegarder Ã  la fermeture
        self.protocol("WM_DELETE_WINDOW", self.on_close)

        # ALWAYS ON TOP
        self.after(500, self.set_always_on_top)

        # Mettre Ã  jour les couleurs du menu selon le mode rÃ©el
        self.update_menu_colors()

        # Afficher la fenÃªtre aprÃ¨s initialisation complÃ¨te
        self.update_idletasks()
        self.deiconify()

    def set_always_on_top(self):
        self.attributes("-topmost", True)
        try:
            subprocess.run(
                ["wmctrl", "-r", self.title(), "-b", "add,above"],
                stderr=subprocess.DEVNULL,
                stdout=subprocess.DEVNULL
            )
        except FileNotFoundError:
            pass

    def ensure_dialog_on_screen(self, dialog):
        """S'assure que le dialogue est entiÃ¨rement visible Ã  l'Ã©cran."""
        dialog.update_idletasks()

        # Dimensions du dialogue
        dlg_width = dialog.winfo_width()
        dlg_height = dialog.winfo_height()

        # Dimensions de l'Ã©cran
        screen_width = dialog.winfo_screenwidth()
        screen_height = dialog.winfo_screenheight()

        # Position de la fenÃªtre principale
        main_x = self.winfo_x()
        main_y = self.winfo_y()
        main_width = self.winfo_width()

        # Positionner prÃ¨s de la fenÃªtre principale
        x = main_x + (main_width - dlg_width) // 2
        y = main_y + 50

        # Ajuster si hors Ã©cran
        if x + dlg_width > screen_width:
            x = screen_width - dlg_width - 10
        if x < 0:
            x = 10
        if y + dlg_height > screen_height:
            y = screen_height - dlg_height - 50
        if y < 0:
            y = 10

        dialog.geometry(f"+{x}+{y}")

    # --------------------------------------------------------
    # TAB COLOR MANAGEMENT
    # --------------------------------------------------------

    def get_tab_bg_state(self, tab):
        """Retourne l'Ã©tat de background pour l'onglet."""
        if not tab.git_healthy:
            return "red"
        if tab.pending_branches and not tab.polling:
            return "red"
        if tab.polling:
            return "green"
        return "default"

    def update_tab_color(self, tab):
        """Met Ã  jour la couleur de l'onglet."""
        tab_name = tab.tab_name
        if tab_name not in self.tab_buttons:
            return

        btn = self.tab_buttons[tab_name]
        bg_state = self.get_tab_bg_state(tab)

        # Define colors
        if bg_state == "green":
            fg_color = "#2d5a2d"  # Dark green
            hover_color = "#3d7a3d"
        elif bg_state == "red":
            fg_color = "#8b2020"  # Dark red
            hover_color = "#ab3030"
        else:
            fg_color = "#3d3d3d"  # Default gray (5% lighter for dark mode)
            hover_color = "#4a4a4a"

        # Update button colors
        btn.configure(fg_color=fg_color, hover_color=hover_color)

        # Update indicator (overlay, ne dÃ©cale pas le texte)
        if tab.syncing:
            btn.set_indicator("â­¯")  # U+2B6F sync indicator
        elif tab.has_update:
            btn.set_indicator("â—")  # U+25CF update indicator
        else:
            btn.set_indicator("")  # Pas d'indicateur

        self.update_title()

    def mark_tab_updated(self, tab):
        """Marque l'onglet comme ayant une mise Ã  jour."""
        if not tab.has_update:
            tab.has_update = True
            self.update_tab_color(tab)

    def clear_tab_marker(self, tab):
        """Efface le marqueur de mise Ã  jour."""
        if tab.has_update:
            tab.has_update = False
            self.update_tab_color(tab)

    def update_menu_colors(self, mode=None):
        """Met Ã  jour les couleurs du menu selon le mode d'apparence."""
        if mode is None:
            mode = self.global_settings.get("appearance_mode", "dark")

        if mode == "dark" or (mode == "system" and ctk.get_appearance_mode() == "Dark"):
            menu_bg = "#2b2b2b"
            menu_fg = "#ffffff"
            menu_active_bg = "#404040"
            menu_active_fg = "#ffffff"
        else:
            menu_bg = "#f0f0f0"
            menu_fg = "#000000"
            menu_active_bg = "#0078d4"
            menu_active_fg = "#ffffff"

        # Update menubar and all submenus
        self.menubar.configure(bg=menu_bg, fg=menu_fg,
                              activebackground=menu_active_bg, activeforeground=menu_active_fg)
        for i in range(self.menubar.index("end") + 1):
            try:
                submenu = self.menubar.nametowidget(self.menubar.entrycget(i, "menu"))
                submenu.configure(bg=menu_bg, fg=menu_fg,
                                 activebackground=menu_active_bg, activeforeground=menu_active_fg)
            except:
                pass

        self.menu_colors = {"bg": menu_bg, "fg": menu_fg, "active_bg": menu_active_bg, "active_fg": menu_active_fg}

    # --------------------------------------------------------
    # GLOBAL SETTINGS DIALOG
    # --------------------------------------------------------

    def show_global_settings(self):
        dialog = ctk.CTkToplevel(self)
        dialog.title("Settings")
        dialog.geometry("500x665")
        dialog.transient(self)
        dialog.wait_visibility()
        dialog.grab_set()
        dialog.resizable(False, False)
        self.ensure_dialog_on_screen(dialog)

        main_frame = ctk.CTkFrame(dialog)
        main_frame.pack(fill="both", expand=True, padx=15, pady=15)

        row = 0

        # === APPEARANCE SECTION ===
        ctk.CTkLabel(main_frame, text="Appearance", font=ctk.CTkFont(weight="bold")).grid(
            row=row, column=0, columnspan=3, sticky="w", pady=(0, 8))
        row += 1

        # Appearance mode
        ctk.CTkLabel(main_frame, text="Mode:").grid(row=row, column=0, sticky="w", pady=8)
        appearance_var = ctk.StringVar(value=self.global_settings.get("appearance_mode", "dark"))

        def on_appearance_change(mode):
            ctk.set_appearance_mode(mode)
            self.update_menu_colors(mode)

        appearance_menu = ctk.CTkOptionMenu(
            main_frame,
            variable=appearance_var,
            values=APPEARANCE_MODES,
            width=150,
            command=on_appearance_change
        )
        appearance_menu.grid(row=row, column=1, sticky="w", pady=8, padx=(10, 0))
        row += 1

        # Color theme
        ctk.CTkLabel(main_frame, text="Color:").grid(row=row, column=0, sticky="w", pady=8)
        theme_var = ctk.StringVar(value=self.global_settings.get("color_theme", "blue"))

        def on_theme_change(new_theme):
            if new_theme != self.global_settings.get("color_theme"):
                self.global_settings["color_theme"] = new_theme
                save_global_settings(self.global_settings)
                dialog.destroy()
                self.rebuild_ui()
                # RÃ©ouvrir le dialog aprÃ¨s rebuild
                self.after(150, self.show_global_settings)

        theme_menu = ctk.CTkOptionMenu(
            main_frame,
            variable=theme_var,
            values=COLOR_THEMES,
            width=150,
            command=on_theme_change
        )
        theme_menu.grid(row=row, column=1, sticky="w", pady=8, padx=(10, 0))
        row += 1

        # Font zoom
        ctk.CTkLabel(main_frame, text="Font zoom:").grid(row=row, column=0, sticky="w", pady=8)
        zoom_var = ctk.DoubleVar(value=self.global_settings.get("font_zoom", 1.0))

        zoom_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        zoom_frame.grid(row=row, column=1, columnspan=2, sticky="w", pady=8, padx=(10, 0))

        zoom_slider = ctk.CTkSlider(
            zoom_frame,
            from_=0.8,
            to=2.0,
            number_of_steps=12,
            variable=zoom_var,
            width=120
        )
        zoom_slider.pack(side="left")

        zoom_label = ctk.CTkLabel(zoom_frame, text=f"{zoom_var.get():.1f}x", width=40)
        zoom_label.pack(side="left", padx=(5, 0))

        # Debounce pour le zoom (applique aprÃ¨s 500ms sans changement)
        zoom_timer = [None]

        def on_zoom_change(val):
            zoom_label.configure(text=f"{float(val):.1f}x")
            # Annuler le timer prÃ©cÃ©dent
            if zoom_timer[0]:
                dialog.after_cancel(zoom_timer[0])
            # Nouveau timer
            def apply_zoom():
                new_zoom = float(val)
                if abs(new_zoom - self.global_settings.get("font_zoom", 1.0)) > 0.01:
                    self.global_settings["font_zoom"] = new_zoom
                    save_global_settings(self.global_settings)
                    dialog.destroy()
                    self.rebuild_ui()
                    # RÃ©ouvrir le dialog aprÃ¨s rebuild
                    self.after(150, self.show_global_settings)
            zoom_timer[0] = dialog.after(500, apply_zoom)

        zoom_slider.configure(command=on_zoom_change)
        row += 1

        # Separator
        ctk.CTkLabel(main_frame, text="").grid(row=row, column=0, pady=5)
        row += 1

        # === GIT SECTION ===
        ctk.CTkLabel(main_frame, text="Git", font=ctk.CTkFont(weight="bold")).grid(
            row=row, column=0, columnspan=3, sticky="w", pady=(0, 8))
        row += 1

        # Git binary
        ctk.CTkLabel(main_frame, text="Executable:").grid(row=row, column=0, sticky="w", pady=8)
        git_entry = ctk.CTkEntry(main_frame, width=250)
        git_entry.insert(0, self.global_settings.get("git_binary", "git"))
        git_entry.grid(row=row, column=1, sticky="ew", pady=8, padx=(10, 5))

        def browse_git():
            path = filedialog.askopenfilename(
                title="Select Git executable",
                filetypes=[("Executables", "*")]
            )
            if path:
                git_entry.delete(0, "end")
                git_entry.insert(0, path)

        ctk.CTkButton(main_frame, text="ğŸ“‚", width=40, command=browse_git).grid(
            row=row, column=2, pady=8)
        row += 1

        # Separator
        ctk.CTkLabel(main_frame, text="").grid(row=row, column=0, pady=5)
        row += 1

        # === SECTION OPTIONS ===
        ctk.CTkLabel(main_frame, text="Options", font=ctk.CTkFont(weight="bold")).grid(
            row=row, column=0, columnspan=3, sticky="w", pady=(0, 8))
        row += 1

        # Auto-start polling
        auto_poll_var = ctk.BooleanVar(value=self.global_settings.get("auto_start_polling", False))
        ctk.CTkCheckBox(main_frame, text="Auto-start polling",
                       variable=auto_poll_var).grid(row=row, column=0, columnspan=3, sticky="w", pady=6)
        row += 1

        # Start collapsed
        collapsed_var = ctk.BooleanVar(value=self.global_settings.get("start_collapsed", False))
        ctk.CTkCheckBox(main_frame, text="Start with log collapsed",
                       variable=collapsed_var).grid(row=row, column=0, columnspan=3, sticky="w", pady=6)
        row += 1

        # Advanced mode
        advanced_var = ctk.BooleanVar(value=self.global_settings.get("advanced_mode", False))
        ctk.CTkCheckBox(main_frame, text="Advanced mode (click tab=polling, double-click=sync)",
                       variable=advanced_var).grid(row=row, column=0, columnspan=3, sticky="w", pady=6)
        row += 1

        # Desktop notifications
        notif_var = ctk.BooleanVar(value=self.global_settings.get("desktop_notifications", True))
        ctk.CTkCheckBox(main_frame, text="Desktop notifications (notify-send)",
                       variable=notif_var).grid(row=row, column=0, columnspan=3, sticky="w", pady=6)
        row += 1

        # Restore polling on restart
        restore_poll_var = ctk.BooleanVar(value=self.global_settings.get("restore_polling", False))
        ctk.CTkCheckBox(main_frame, text="Restore polling state on restart",
                       variable=restore_poll_var).grid(row=row, column=0, columnspan=3, sticky="w", pady=6)
        row += 1

        # Sync new branches by default
        sync_new_var = ctk.BooleanVar(value=self.global_settings.get("sync_new_branches_by_default", False))
        ctk.CTkCheckBox(main_frame, text="Enable sync for newly discovered branches",
                       variable=sync_new_var).grid(row=row, column=0, columnspan=3, sticky="w", pady=6)
        row += 1

        main_frame.columnconfigure(1, weight=1)

        # Buttons
        btn_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        btn_frame.pack(fill="x", padx=15, pady=15)

        def save_settings():
            # Theme et zoom sont appliquÃ©s en direct, ici on sauve le reste
            old_advanced = self.global_settings.get("advanced_mode", False)
            new_advanced = advanced_var.get()

            self.global_settings["appearance_mode"] = appearance_var.get()
            self.global_settings["git_binary"] = git_entry.get().strip()
            self.global_settings["auto_start_polling"] = auto_poll_var.get()
            self.global_settings["start_collapsed"] = collapsed_var.get()
            self.global_settings["advanced_mode"] = new_advanced
            self.global_settings["desktop_notifications"] = notif_var.get()
            self.global_settings["restore_polling"] = restore_poll_var.get()
            self.global_settings["sync_new_branches_by_default"] = sync_new_var.get()

            try:
                save_global_settings(self.global_settings)
            except Exception as e:
                messagebox.showerror("Error", f"Unable to save: {e}", parent=dialog)
                return

            dialog.destroy()

            # Rebuild UI if advanced mode changed
            if old_advanced != new_advanced:
                self.rebuild_ui()

        ctk.CTkButton(btn_frame, text="Save", command=save_settings).pack(side="left", padx=5)
        ctk.CTkButton(btn_frame, text="Cancel", command=dialog.destroy).pack(side="left", padx=5)

    # --------------------------------------------------------
    # REPOS MANAGEMENT
    # --------------------------------------------------------

    def load_saved_repos(self):
        repos = load_saved_repos()
        git = self.global_settings.get("git_binary", "git")
        for repo_path in repos:
            if Path(repo_path).exists() and is_git_repo(repo_path, git):
                self.add_repo(repo_path, switch_to=False)  # Ne pas switcher pendant le chargement

        # Restore last active tab (delayed to ensure UI is ready)
        def restore_tab():
            last_tab = self.global_settings.get("last_active_tab", "")
            if last_tab and last_tab in self.tabs:
                self.switch_tab(last_tab)
            elif self.tabs:
                # Show first tab if no saved tab
                first_tab = list(self.tabs.keys())[0]
                self.switch_tab(first_tab)

        def restore_polling():
            """Restaure l'Ã©tat du polling si l'option est activÃ©e."""
            if not self.global_settings.get("restore_polling", False):
                return
            polling_states = self.global_settings.get("polling_states", {})
            for tab_name, tab in self.tabs.items():
                repo_path = self.tab_paths.get(tab_name, "")
                if repo_path and polling_states.get(repo_path, False):
                    if tab.git_healthy and not tab.polling:
                        tab.toggle_polling()

        self.after(100, restore_tab)
        self.after(200, restore_polling)  # AprÃ¨s restore_tab

    def save_current_repos(self):
        repos = list(self.tab_paths.values())
        save_repos(repos)

    def save_window_state(self):
        """Sauvegarde la position et l'Ã©tat de la fenÃªtre pour le restart."""
        import re
        self.update_idletasks()
        geom = self.geometry()
        match = re.match(r"(\d+)x(\d+)\+(-?\d+)\+(-?\d+)", geom)
        if match:
            self.global_settings["window_x"] = int(match.group(3))
            self.global_settings["window_y"] = int(match.group(4))

        # Sauvegarder l'Ã©tat collapsed (basÃ© sur le tab actif)
        if self.current_tab and self.current_tab in self.tabs:
            current_tab_obj = self.tabs[self.current_tab]
            self.global_settings["start_collapsed"] = not current_tab_obj.log_visible
            # Sauvegarder l'onglet actif
            self.global_settings["last_active_tab"] = self.current_tab

        # Toujours sauvegarder l'Ã©tat du polling pour chaque repo
        polling_states = {}
        for tab_name, tab in self.tabs.items():
            repo_path = self.tab_paths.get(tab_name, "")
            if repo_path:
                polling_states[repo_path] = tab.polling
        self.global_settings["polling_states"] = polling_states

        save_global_settings(self.global_settings)

    def add_repo_dialog(self):
        path = filedialog.askdirectory(
            title="Select a Git repository",
            mustexist=True
        )
        if path:
            git = self.global_settings.get("git_binary", "git")
            if not is_git_repo(path, git):
                messagebox.showerror(
                    "Error",
                    f"'{path}' is not a valid Git repository.",
                    parent=self
                )
                return
            if path in self.tab_paths.values():
                messagebox.showinfo(
                    "Info",
                    "This repository is already open.",
                    parent=self
                )
                return

            detected = detect_repo_settings(path, git)
            config_file = Path(path) / "githerd.toml"
            if not config_file.exists():
                save_repo_config(path, detected)

            self.add_repo(path)
            self.save_current_repos()

    def add_repo(self, repo_path, switch_to=True):
        repo_name = Path(repo_path).name

        # GÃ©rer les noms en double
        tab_name = repo_name
        counter = 1
        while tab_name in self.tabs:
            counter += 1
            tab_name = f"{repo_name} ({counter})"

        # Create tab button with custom indicator overlay
        btn = TabButton(
            self.tab_bar,
            text=repo_name,
            fg_color="#3d3d3d",  # LÃ©gÃ¨rement plus clair en dark mode
            hover_color="#4a4a4a",
            corner_radius=8,
            height=32,
            command=lambda n=tab_name: self.on_tab_click(n)
        )
        btn.pack(side="left", padx=(0, 8), pady=8)
        # Double-clic pour sync now (mode avancÃ©)
        btn.bind("<Double-Button-1>", lambda e, n=tab_name: self.on_tab_double_click(n))
        self.tab_buttons[tab_name] = btn

        # CrÃ©er le contenu directement dans le container
        tab_content = RepoTabContent(self.content_container, repo_path, self, tab_name)
        self.tab_frames[tab_name] = tab_content  # Store content directly

        self.tabs[tab_name] = tab_content
        self.tab_paths[tab_name] = repo_path

        # Switch to new tab seulement si demandÃ©
        if switch_to:
            self.switch_tab(tab_name)
        self.after(100, self.update_title)

        # Auto-start polling si activÃ© ET restore_polling dÃ©sactivÃ©
        # (si restore_polling est activÃ©, c'est restore_polling() qui gÃ¨re l'Ã©tat)
        if self.global_settings.get("auto_start_polling", False) and not self.global_settings.get("restore_polling", False):
            self.after(500, tab_content.toggle_polling)

    def on_tab_click(self, tab_name):
        """Handle tab click - switch or toggle polling in advanced mode."""
        if self.global_settings.get("advanced_mode", False):
            # Mode avancÃ©: attendre pour distinguer simple/double clic
            # Annuler le timer prÃ©cÃ©dent s'il existe
            if hasattr(self, '_click_timer') and self._click_timer:
                self.after_cancel(self._click_timer)
                self._click_timer = None

            # DÃ©marrer un timer pour le simple clic (300ms)
            def do_single_click():
                self._click_timer = None
                if self.current_tab == tab_name:
                    # DÃ©jÃ  sÃ©lectionnÃ© -> toggle polling
                    tab = self.tabs.get(tab_name)
                    if tab and tab.git_healthy:
                        tab.toggle_polling()
                else:
                    # Pas sÃ©lectionnÃ© -> switch
                    self.switch_tab(tab_name)

            self._click_timer = self.after(300, do_single_click)
            self._click_tab = tab_name
        else:
            # Mode normal: switch immÃ©diat
            self.switch_tab(tab_name)

    def on_tab_double_click(self, tab_name):
        """Handle tab double-click - sync now in advanced mode."""
        if self.global_settings.get("advanced_mode", False):
            # Annuler le timer du simple clic
            if hasattr(self, '_click_timer') and self._click_timer:
                self.after_cancel(self._click_timer)
                self._click_timer = None

            tab = self.tabs.get(tab_name)
            if tab and tab.git_healthy:
                tab.manual_sync()

    def switch_tab(self, tab_name):
        """Switch to specified tab."""
        if tab_name not in self.tabs:
            return

        # Hide current tab
        if self.current_tab and self.current_tab in self.tab_frames:
            self.tab_frames[self.current_tab].pack_forget()
            # Reset previous button border
            if self.current_tab in self.tab_buttons:
                self.tab_buttons[self.current_tab].configure(border_width=0)

        # Show new tab
        self.tab_frames[tab_name].pack(fill="both", expand=True)
        self.current_tab = tab_name

        # Highlight active button with subtle border
        self.tab_buttons[tab_name].configure(border_width=1, border_color="#888888")

        # Mark as read
        tab = self.tabs[tab_name]
        if tab.has_update:
            tab.has_update = False
            self.update_tab_color(tab)

        # Update Repository menu for new tab
        self.update_repo_menu()

    def close_tab(self, tab_name):
        if tab_name in self.tabs:
            tab = self.tabs[tab_name]
            # ArrÃªter le polling proprement
            if tab.polling:
                tab.polling = False
                tab.stop_event.set()
            tab.stop_countdown()
            # Attendre la fin du thread (max 5s)
            tab.wait_for_polling_thread(timeout=5)

            # Remove button
            if tab_name in self.tab_buttons:
                self.tab_buttons[tab_name].destroy()
                del self.tab_buttons[tab_name]

            # Remove content (tab_frames points to same object as tabs)
            if tab_name in self.tab_frames:
                del self.tab_frames[tab_name]

            # Destroy the tab content widget
            tab.destroy()
            del self.tabs[tab_name]
            del self.tab_paths[tab_name]

            # Switch to another tab if needed
            if self.current_tab == tab_name:
                self.current_tab = None
                if self.tabs:
                    first_tab = list(self.tabs.keys())[0]
                    self.switch_tab(first_tab)

            self.save_current_repos()
            self.update_title()

    # --------------------------------------------------------
    # TITLE UPDATE
    # --------------------------------------------------------

    def update_title(self):
        total = len(self.tabs)
        polling = sum(1 for t in self.tabs.values() if t.polling)
        stopped = sum(1 for t in self.tabs.values() if t.pending_branches and not t.polling)

        if total == 0:
            self.title("GitHerd")
        elif stopped > 0:
            self.title(f"GitHerd â€” {total} repos, {polling} polling, {stopped} STOP")
        elif polling > 0:
            self.title(f"GitHerd â€” {total} repos, {polling} polling")
        else:
            self.title(f"GitHerd â€” {total} repos")

    def stop_all_polling(self):
        stopped = 0
        for tab in self.tabs.values():
            if tab.polling:
                tab.polling = False
                tab.stop_event.set()  # Signal au thread de s'arrÃªter
                tab.stop_countdown()
                tab.btn_poll.configure(text="â–¶ Start polling")
                self.update_tab_color(tab)
                stopped += 1

        self.update_title()

        if stopped > 0:
            self.after(100, lambda: messagebox.showinfo(
                "Polling stopped",
                f"{stopped} polling(s) stopped.",
                parent=self
            ))

    def get_current_tab(self):
        """Get the current tab content object."""
        if not self.tabs or not self.current_tab:
            return None
        return self.tabs.get(self.current_tab)

    def update_repo_menu(self):
        """Rebuild the Repository menu for current tab."""
        self.repo_menu.delete(0, "end")

        tab = self.get_current_tab()
        if not tab:
            self.repo_menu.add_command(label="(no repository)", state="disabled")
            return

        # Options
        self.repo_menu.add_command(label="Options...", command=tab.show_config_dialog)
        self.repo_menu.add_command(label="Open folder", command=tab.open_folder)
        self.repo_menu.add_separator()

        # Sync actions
        self.repo_menu.add_command(
            label="Sync now",
            command=tab.manual_sync,
            state="normal" if tab.git_healthy else "disabled"
        )

        polling_label = "Stop polling" if tab.polling else "Start polling"
        self.repo_menu.add_command(
            label=polling_label,
            command=tab.toggle_polling,
            state="normal" if tab.git_healthy else "disabled"
        )

        self.repo_menu.add_separator()

        # List branches matching prefix
        try:
            branches = get_tracked_branches(tab.remote, tab.prefix,
                                           cwd=tab.repo_path, git=tab.git)
        except:
            branches = []

        # Branch update toggles (enabled/disabled)
        if branches:
            settings = load_global_settings()
            branch_states = settings.get("branch_update_enabled", {}).get(str(tab.repo_path), {})
            default_enabled = settings.get("sync_new_branches_by_default", False)
            for b in branches:
                short_name = b.replace(f"{tab.remote}/", "")
                is_enabled = branch_states.get(short_name, default_enabled)
                checkmark = "âœ“ " if is_enabled else "   "
                self.repo_menu.add_command(
                    label=f"{checkmark}{short_name}",
                    command=lambda bn=short_name: self.toggle_branch_update(tab.repo_path, bn)
                )
            self.repo_menu.add_separator()

        # Delete branch options
        if branches:
            for b in branches:
                short_name = b.replace(f"{tab.remote}/", "")
                self.repo_menu.add_command(
                    label=f"Delete {short_name}",
                    command=lambda bn=short_name: tab.delete_branch(bn)
                )
            self.repo_menu.add_separator()

        # Close tab
        self.repo_menu.add_command(label="Close", command=self.close_current_tab)

    def toggle_branch_update(self, repo_path, branch_name):
        """Toggle branch update enabled/disabled state and save to settings."""
        settings = load_global_settings()
        branch_states = settings.setdefault("branch_update_enabled", {})
        repo_states = branch_states.setdefault(str(repo_path), {})

        # Toggle: use sync_new_branches_by_default as default value
        default_enabled = settings.get("sync_new_branches_by_default", False)
        current = repo_states.get(branch_name, default_enabled)
        repo_states[branch_name] = not current

        save_global_settings(settings)
        self.update_repo_menu()

    def show_current_repo_options(self):
        """Show options for current repository."""
        tab = self.get_current_tab()
        if tab:
            tab.show_config_dialog()

    def open_current_folder(self):
        """Open current repository folder."""
        tab = self.get_current_tab()
        if tab:
            tab.open_folder()

    def close_current_tab(self):
        """Close current repository tab."""
        if not self.tabs or not self.current_tab:
            return
        self.close_tab(self.current_tab)

    def rebuild_ui(self):
        """Reconstruit l'interface sans redÃ©marrer le processus."""
        import tkinter as tk
        import tkinter.font as tkfont

        # Sauvegarder l'Ã©tat actuel
        saved_current_tab = self.current_tab
        saved_repos = list(self.tab_paths.values())
        saved_geometry = self.geometry()

        # ArrÃªter tous les polling proprement
        for tab in self.tabs.values():
            if tab.polling:
                tab.polling = False
                tab.stop_event.set()
                tab.stop_countdown()

        # Attendre que tous les threads se terminent
        def do_rebuild():
            any_alive = any(
                tab.polling_thread and tab.polling_thread.is_alive()
                for tab in self.tabs.values()
            )
            if any_alive:
                self.after(200, do_rebuild)
                return

            # Cacher la fenÃªtre pendant la reconstruction
            self.withdraw()

            # DÃ©truire tous les widgets enfants
            for widget in self.winfo_children():
                widget.destroy()

            # RÃ©initialiser les structures
            self.tabs = {}
            self.tab_paths = {}
            self.tab_buttons = {}
            self.tab_frames = {}
            self.current_tab = None

            # Appliquer le nouveau thÃ¨me
            apply_theme_settings()

            # RecrÃ©er le menu bar
            font_zoom = self.global_settings.get("font_zoom", 1.0)
            ctk.set_widget_scaling(font_zoom)
            ctk.set_window_scaling(font_zoom)

            menu_font_size = int(10 * font_zoom)
            menu_font = tkfont.Font(family="sans-serif", size=menu_font_size)

            # Couleurs selon le mode d'apparence
            appearance = self.global_settings.get("appearance_mode", "dark")
            if appearance == "dark" or (appearance == "system" and ctk.get_appearance_mode() == "Dark"):
                menu_bg = "#2b2b2b"
                menu_fg = "#ffffff"
                menu_active_bg = "#404040"
                menu_active_fg = "#ffffff"
            else:
                menu_bg = "#f0f0f0"
                menu_fg = "#000000"
                menu_active_bg = "#0078d4"
                menu_active_fg = "#ffffff"

            self.menubar = tk.Menu(self, font=menu_font, bg=menu_bg, fg=menu_fg,
                                   activebackground=menu_active_bg, activeforeground=menu_active_fg)
            self.config(menu=self.menubar)

            # File menu
            file_menu = tk.Menu(self.menubar, tearoff=0, font=menu_font, bg=menu_bg, fg=menu_fg,
                               activebackground=menu_active_bg, activeforeground=menu_active_fg)
            self.menubar.add_cascade(label="\u00a0\u00a0\u00a0File\u00a0\u00a0\u00a0", menu=file_menu)
            file_menu.add_command(label="Add repository...", command=self.add_repo_dialog,
                                 accelerator="Ctrl+O")
            file_menu.add_command(label="Stop all polling", command=self.stop_all_polling,
                                 accelerator="Ctrl+S")
            file_menu.add_separator()
            file_menu.add_command(label="Restart", command=self.restart_app,
                                 accelerator="Ctrl+R")
            file_menu.add_command(label="Quit", command=self.on_close, accelerator="Ctrl+Q")

            # Repository menu
            self.repo_menu = tk.Menu(self.menubar, tearoff=0, font=menu_font, bg=menu_bg, fg=menu_fg,
                                    activebackground=menu_active_bg, activeforeground=menu_active_fg)
            self.menu_font = menu_font
            self.menu_colors = {"bg": menu_bg, "fg": menu_fg, "active_bg": menu_active_bg, "active_fg": menu_active_fg}
            self.menubar.add_cascade(label="\u00a0\u00a0\u00a0Repository\u00a0\u00a0\u00a0", menu=self.repo_menu)

            # ? menu
            help_menu = tk.Menu(self.menubar, tearoff=0, font=menu_font, bg=menu_bg, fg=menu_fg,
                               activebackground=menu_active_bg, activeforeground=menu_active_fg)
            self.menubar.add_cascade(label="\u00a0\u00a0\u00a0?\u00a0\u00a0\u00a0", menu=help_menu)
            help_menu.add_command(label="Settings...", command=self.show_global_settings)
            help_menu.add_separator()
            help_menu.add_command(label="Help", command=self.show_help)
            help_menu.add_command(label="About GitHerd", command=self.show_about)

            # RecrÃ©er la tab bar
            self.tab_bar = ctk.CTkFrame(self, height=40)
            self.tab_bar.pack(fill="x", padx=10, pady=(10, 0))

            # Container pour le contenu
            self.content_container = ctk.CTkFrame(self)
            self.content_container.pack(fill="both", expand=True, padx=10, pady=(5, 10))

            # Recharger les repos
            git = self.global_settings.get("git_binary", "git")
            for repo_path in saved_repos:
                if Path(repo_path).exists() and is_git_repo(repo_path, git):
                    self.add_repo(repo_path)

            # Restaurer l'onglet actif
            def restore():
                if saved_current_tab and saved_current_tab in self.tabs:
                    self.switch_tab(saved_current_tab)
                elif self.tabs:
                    first_tab = list(self.tabs.keys())[0]
                    self.switch_tab(first_tab)

            self.after(100, restore)

            # Restaurer la gÃ©omÃ©trie et rÃ©afficher la fenÃªtre
            self.geometry(saved_geometry)
            self.update_idletasks()
            self.deiconify()

        do_rebuild()

    def restart_app(self):
        any_sync_locked = any(tab.lock.locked() for tab in self.tabs.values())
        polling_count = sum(1 for tab in self.tabs.values() if tab.polling)

        if any_sync_locked or polling_count > 0:
            # Custom dialog with Cancel and Restart buttons
            dialog = ctk.CTkToplevel(self)
            dialog.title("Restart")
            dialog.geometry("400x180")
            dialog.transient(self)
            dialog.wait_visibility()
            dialog.grab_set()
            dialog.resizable(False, False)
            self.ensure_dialog_on_screen(dialog)

            frame = ctk.CTkFrame(dialog)
            frame.pack(fill="both", expand=True, padx=20, pady=20)

            if any_sync_locked:
                msg = "A synchronization is in progress.\n\nRestart will wait for it to finish, then stop polling."
            else:
                msg = f"{polling_count} polling(s) active.\n\nRestart will stop all polling."

            ctk.CTkLabel(frame, text=msg, justify="center").pack(pady=20)

            btn_frame = ctk.CTkFrame(frame, fg_color="transparent")
            btn_frame.pack(pady=10)

            def do_restart():
                dialog.destroy()
                # Signaler Ã  tous les threads de s'arrÃªter
                for tab in self.tabs.values():
                    if tab.polling:
                        tab.polling = False
                        tab.stop_event.set()
                        tab.stop_countdown()

                # Attendre que tous les threads se terminent
                def wait_and_restart():
                    # VÃ©rifier si des threads sont encore actifs
                    any_alive = any(
                        tab.polling_thread and tab.polling_thread.is_alive()
                        for tab in self.tabs.values()
                    )
                    if any_alive:
                        self.after(500, wait_and_restart)
                    else:
                        self.save_window_state()
                        self.save_current_repos()
                        python = sys.executable
                        script = os.path.abspath(__file__)
                        self.destroy()
                        # Utiliser subprocess.Popen + sys.exit au lieu de os.execl
                        subprocess.Popen([python, script])
                        sys.exit(0)

                wait_and_restart()

            ctk.CTkButton(btn_frame, text="Cancel", width=100,
                         command=dialog.destroy).pack(side="left", padx=10)
            ctk.CTkButton(btn_frame, text="Restart", width=100,
                         fg_color="#8B0000", hover_color="#CD5C5C",
                         command=do_restart).pack(side="left", padx=10)
            return

        # No sync or polling - restart immediately
        self.save_window_state()
        self.save_current_repos()
        python = sys.executable
        script = os.path.abspath(__file__)
        self.destroy()
        # Utiliser subprocess.Popen + sys.exit au lieu de os.execl
        subprocess.Popen([python, script])
        sys.exit(0)

    def show_about(self):
        about_win = ctk.CTkToplevel(self)
        about_win.title("About GitHerd")
        about_win.geometry("400x400")
        about_win.transient(self)
        about_win.wait_visibility()
        about_win.grab_set()
        about_win.resizable(False, False)
        self.ensure_dialog_on_screen(about_win)

        # Main frame
        frame = ctk.CTkFrame(about_win)
        frame.pack(fill="both", expand=True, padx=20, pady=20)

        # Title
        ctk.CTkLabel(
            frame,
            text="GitHerd",
            font=ctk.CTkFont(size=28, weight="bold")
        ).pack(pady=(20, 5))

        # Version
        ctk.CTkLabel(
            frame,
            text="Version 1.0",
            font=ctk.CTkFont(size=14),
            text_color="gray"
        ).pack()

        # Description
        ctk.CTkLabel(
            frame,
            text="Real-time Git branch synchronizer",
            font=ctk.CTkFont(size=13)
        ).pack(pady=(15, 5))

        ctk.CTkLabel(
            frame,
            text="Keeps multiple Git branches aligned in real-time.\nIdeal for parallel AI coding sessions.",
            font=ctk.CTkFont(size=12),
            text_color="gray",
            justify="center"
        ).pack()

        # Copyright
        ctk.CTkLabel(
            frame,
            text="Â© 2026 InZeMobile â€” Jacques Lovi",
            font=ctk.CTkFont(size=12)
        ).pack(pady=(20, 5))

        ctk.CTkLabel(
            frame,
            text="All rights reserved",
            font=ctk.CTkFont(size=11),
            text_color="gray"
        ).pack()

        # Close button
        ctk.CTkButton(about_win, text="Close", command=about_win.destroy, width=100).pack(pady=15)

    def show_help(self):
        help_win = ctk.CTkToplevel(self)
        help_win.title("Help â€” GitHerd")
        help_win.geometry("700x600")
        help_win.transient(self)
        help_win.wait_visibility()
        help_win.grab_set()
        self.ensure_dialog_on_screen(help_win)

        text = ctk.CTkTextbox(help_win, font=ctk.CTkFont(family="Consolas", size=12))
        text.pack(fill="both", expand=True, padx=10, pady=10)
        text.insert("1.0", HELP_TEXT)
        text.configure(state="disabled")

        ctk.CTkButton(help_win, text="Close", command=help_win.destroy).pack(pady=10)

    def on_close(self):
        # Signaler Ã  tous les threads de s'arrÃªter
        for tab in self.tabs.values():
            if tab.polling:
                tab.polling = False
                tab.stop_event.set()

        # Attendre que tous les threads se terminent proprement
        # (chaque thread finit son opÃ©ration git en cours avant de s'arrÃªter)
        for tab in self.tabs.values():
            tab.wait_for_polling_thread(timeout=30)  # Max 30s par thread

        # Save last active tab
        if self.tabs and self.current_tab:
            self.global_settings["last_active_tab"] = self.current_tab
            save_global_settings(self.global_settings)

        self.save_current_repos()
        self.destroy()


# ============================================================

if __name__ == "__main__":
    apply_theme_settings()
    App().mainloop()
